# Table of Contents

- [Introduction](#1)
  - [Post-exploitation methodology](#1.1)
- [Local Enumeration](#2)
  - [Windows Local Enumeration](#2.1)
    - [Network information](#2.1.1)
    - [System information](#2.1.2)
    - [Users and groups](#2.1.3)
    - [Processes and services](#2.1.4)
    - [Automating Windows Enumeration](#2.1.5)
  - [Linux Local Enumeration](#2.2)
    - [System information](#2.2.1)
    - [Users and groups](#2.2.2)
    - [Network information](#2.2.3)
    - [Enumerating services, processes and cronjobs.](#2.2.4)
    - [Automating Linux Enumeration](#2.2.5)
- [Transferring Files](#3)
  - [Setting up a web server in Python](#3.1)
  - [Transferring Files to a Windows system](#3.2)
  - [Transferring Files to a Linux system](#3.3)

<a id=1></a>
# Introduction

In this course we'll learn how to enumerate local information, how to search for privilege escalation vectors,
how to pivot from system to system in-depth, upgrading shells (non-interactive sessions) to interactive shells or
meterpreter shells, dumping and cracking hashes and finally how to clear our tracks in Windows and Linux.

It is the final phase of a penetration test life cycle. It's all the tactics and techniques an attacker does when
they gain initial access to a target system.

This tactics and techniques will further depend on what access you have on the target system and how stealthy you have to
be. You'll be able to use some tools depending on your privileges, and some you may not. For example: if you have access
to a service account in Windows, you won't be able to dump credentials from the SAM database.

<a id=1.1></a>
## Post-exploitation methodology

As we've probably already realized, post-exploitation is a complex stage made out of lots of smaller stages. This means that
as pentesters, we might forget to do some of them. For example, we might forget to clear our tracks. For this, we have to
take a methodological approach to post-exploitation so we don't miss any stage in order to have a correct post-exploitation
phase.

1. Local enumeration: process in which we gain information about a system.
2. Transferring files: process in which we upload files and binaries to a system.
3. Upgrading shells: process in which we get a better shell than we previously had.
4. Privilege escalation: process in which we elevate our privileges to SYSTEM or root privileges.
5. Persistence: process in which we can get continuous access to a system through system reboots and connection issues.
6. Dumping and cracking hashes: process in which we get plaintext credentials to further exploit a system. This stage is not only
present on post-exploitation, as you might get an NTLM hash or TGS (Ticket Granting Service) from Kerberos and stole that from
the network.
7. Pivoting: process in which we scan the network in which a target is located to jump and exploit other machines.
8. Clearing tracks: process in which we clear all evidence about our actions and the fact that we exploited a machine.
*What? I didn't do anything! Check the logs! :)* 


<a id=2></a>
# Local Enumeration

Local enumeration is the process of gathering as much information as possible from a hacked system to get more privileges,
credentials, access to other machines, and a lot more. The process will differ depending on the operating system.

<a id=2.1></a>
## Windows Local Enumeration

<a id=2.1.1></a>
### System information

After gaining initial access to a system, its very important to gain knowledge upon the system. We'll look for hostnames,
operating system version and patches installed, build, service pack, system architecture.

```bash
C:\> hostname
# get hostname
C:\> systeminfo
# get sysinfo
C:\> wmic qfe get Caption,Description,HotFixID,InstalledOn
# get patches installed
C:\> type C:\Windows\system32\eula.txt
# perhaps get some more info on the build version and stuff
C:\> type %SYSTEMDRIVE%\boot.ini
# get boot info
C:\> type %WINDIR%\win.ini
# get windows info
C:\> type %WINDIR%\System32\drivers\etc\hosts
# type the hosts, i.e local DNS entries
C:\>  type %SYSTEMDRIVE%\pagefile.sys
C:\> type %WINDIR%\debug\NetSetup.log
C:\> type %WINDIR%\repair\sam
C:\> type %WINDIR%\repair\system
C:\> type %WINDIR%\repair\software
C:\> type %WINDIR%\repair\security
C:\> type %WINDIR%\iis6.log
C:\> type %WINDIR%\system32\config\AppEvent.Evt
C:\> type %WINDIR%\system32\config\SecEvent.Evt
C:\> type %WINDIR%\system32\config\default.sav
C:\> type %WINDIR%\system32\config\security.sav
C:\> type %WINDIR%\system32\config\software.sav
C:\> type %WINDIR%\system32\config\system.sav
C:\> type %WINDIR%\system32\CCM\logs\*.log
C:\> type %USERPROFILE%\ntuser.dat
C:\> type %USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
# a shit load of important info we may care about. either pull it from the system,
# make a script that will take all this info into a single file and then send it over
# to your system
C:\> driverquery
C:\> fsutil fsinfo drives
C:\> set
C:\> qwinsta
C:\> net time
C:\> net file
C:\> net session
C:\> net use
C:\> driverquery | findstr Kernel
# useful query if looking for kernel exploits :)
```

<a id=2.1.2></a>
### Users and groups

After gaining access to a system, it's always important to learn more about the system. What users access it?
What account am I in control of? What are we looking for?

- Current user and privileges
- Additional user information
- Other users on the system
- Groups 
- Member of the built-in administrators group

```bash
meterpreter > getuid
meterpreter > getprivs
msf6 > use post/windows/gather/enum_logged_on_users
msf6 post(windows/gather/enum_logged_on_users) > set SESSION [SESSION_ID]
# get all users that have logged on to the victim system.
C:\> net user
C:\> net user /DOMAIN
# enumerate all local users and domain users
C:\> whoami /priv
# enumerate user privileges
C:\> whoami /all
# list username and more info
C:\> echo %USERNAME%
# same as whoami but for older systems
C:\> query user
# enumerate logged on users
C:\> net user [USERNAME]
# get more info on [USERNAME].
C:\> net localgroup
# enumerate local groups on a system
```

<a id=2.1.3></a>
### Network information

In this section we'll be looking for network info. This info will be important for the pivoting phase. The info that we're 
looking for is:

- Current IP address and network adapter.
- Internal networks.
- TCP/UDP services running and their respective ports.
- Others hosts in the network.
- Routing table.
- Windows Firewall rules and state.
- Hosts file.

```bash
C:\> ipconfig
C:\> ipconfig /ALL
# query info on the network adapters
C:\> route print
# show routes
C:\> arp -a
C:\> sc queryex type= service state= all
C:\> netstat -ano
# print service information
C:\> netsh firewall show state 
# check firewall state
C:\> netsh advfirewall firewall dump fileName.wfw
C:\> netsh advfirewall firewall export fileName.wfw
# get all the firewall rules. both commands do the same, but it will depend on the
# windows version.
C:\> netsh advfirewall show allprofiles
# check firewall state verbose
C:\> type %WINDIR%\System32\drivers\etc\hosts
C:\> type C:\Windows\System32\drivers\etc\hosts
# print the hosts file. first one is the CMD variable.
```

<a id=2.1.4></a>
### Processes and services

After we gain access to a system, it's always important to gain knowledge on what processes and services are
running on the system. This is important due to several reasons, but some of them are:

- Process migration.
- Injecting malware to processes.
- Privilege escalation possibilities.

Let's see how to do it.
```bash
meterpreter > ps
C:\> tasklist /SVC
# get a list of tasks running (processes)
meterpreter > pgrep [PROCESS_NAME]
# get PID of [PROCESS_NAME]. it's recommended to migrate to a stable process like explorer.exe to avoid
# losing a meterpreter shell.
C:\> net start
# started services on a system    
C:\> wmic service list {brief}
# similar to systemctl list-units.
C:\> schtask /query /fo LIST {/v}
# enumerate all scheduled tasks.
C:\> sc query [SERVICE_NAME]
C:\> sc start [SERVICE NAME]
C:\> sc stop [SERVICE NAME]
# query, start or stop a specific service.
```

<a id=2.1.5></a>
### Automating Windows Enumeration

As pentesters, we have to be time efficient. For that, we have the possibility to use automation tools for enumerating different
information in a system. While knowing how to enumerate information manually is useful, and in some cases the only way in which
we can get any information from a system, automation tools are quicker, and sometimes better.

We'll use the following tools:

- [JAWS (Just Another Windows (Enum) Script)](https://github.com/411Hall/JAWS)
- [WinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS)
- Metasploit Framework

Note: use Ctrl+Shift+Alt to check the Guacamole clipboard.

```bash
msf6 > use post/windows/gather/win_privs
msf6 post(windows/gather/win_privs) > set SESSION [SESSION_ID]
msf6 post(windows/gather/win_privs) > run
msf6 post(windows/gather/win_privs) > use post/windows/gather/enum_logged_on_users
msf6 post(windows/gather/enum_logged_on_users) > set SESSION [SESSION_ID]
msf6 post(windows/gather/enum_logged_on_users) > run
msf6 post(windows/gather/enum_logged_on_users) > use post/windows/gather/checkvm
msf6 post(windows/gather/checkvm) > set SESSION [SESSION_ID]
msf6 post(windows/gather/checkvm) > run
msf6 post(windows/gather/checkvm) > use post/windows/gather/enum_applications
msf6 post(windows/gather/enum_applications) > set SESSION [SESSION_ID]
msf6 post(windows/gather/enum_applications) > run
msf6 post(windows/gather/enum_applications) > use post/windows/gather/enum_computers
msf6 post(windows/gather/enum_computers) > set SESSION [SESSION_ID]
msf6 post(windows/gather/enum_computers) > run
msf6 post(windows/gather/enum_computers) > use post/windows/gather/enum_patches
msf6 post(windows/gather/enum_patches) > set SESSION [SESSION_ID]
msf6 post(windows/gather/enum_patches) > run
msf6 post(windows/gather/enum_patches) > use post/windows/gather/enum_shares
msf6 post(windows/gather/enum_shares) > set SESSION [SESSION_ID]
meterpreter > cd C:\\
meterpreter > mkdir Temp
meterpreter > cd Temp\\
meterpreter > upload jaws-enum.ps1
meterpreter > upload winpeas.ps1
meterpreter > shell
C:\> powershell.exe -ExecutionPolicy Bypass -File .\jaws-enum.ps1 -OutputFilename jaws-enum.txt
C:\> powershell.exe -ExecutionPolicy Bypass -File .\winpeas.ps1 -OutputFilename winpeas.txt
```


<a id=2.2></a>
## Linux Local Enumeration

In Linux, we will be searching for the following:

- Hostname.
- Distribution and distribution release.
- Kernel version and architecture.
- CPU information.
- Disk information and mounted drives.
- Installed packages and software.
- Network information.
- Passwords, hashes and user accounts.
- Vulnerable SUID binaries.
- Cron tasks.

<a id=2.2.1></a>
### System information

Let's start enumerating some shtuff.

```bash
$ hostname
$ cat /etc/passwd
$ cat /etc/*issue
$ cat /etc/*release
$ uname {-a|-r}
$ env
$ lscpu || cat /proc/cpuinfo
$ free -h || cat /proc/meminfo
$ df -h || df -ht [FILESYSTEM]
$ lsblk || cat /etc/fstab
$ dpkg -l || pacman -Qen || dnf list installed || yum list installed
# will depend on distro
```

Note: I have [another repo](https://github.com/ssepi0l-pv/nerd-notes/blob/master/InfoSec/PrivEsc/LINUX_README.md) which talks a little bit on
this topic. 

<a id=2.2.2></a>
### Users and groups

Let's hunt.

```bash
$ whoami
$ id
$ groups [USERNAME]
$ cat /etc/passwd
$ cat /etc/passwd | grep -v /nologin
$ cat /etc/shadow 
# if possible
$ cat /etc/group
$ who
$ last
$ lastlog
```

<a id=2.2.3></a>
### Network information

```bash
$ ip a
$ ip link
$ cat /etc/hosts
$ netstat -tl
$ ip route show 
$ cat /etc/resolv.conf
$ arp -a || ip neigh
# depends on whether arp is installed or not
```

<a id=2.2.4></a>
### Enumerating services, processes and cronjobs.

```bash
$ systemclt list-units
$ ps aux
$ ps aux | grep [SERVICE_NAME/PROCESS_NAME]
# get process by name
$ ls /proc -la || top
# check running processes without ps
$ crontab -l
$ ls /etc/*cron*
```

<a id=2.1.5></a>
### Automating Linux Enumeration

We learnt how to enumerate files and important information on a Linux system, but this is time consuming and sometimes we can
automate this tasks with tools like the following:

- [LinEnum](https://github.com/rebootuser/LinEnum)
- [Linpeas](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS)
- Metasploit Framework

```bash
msf6 > use post/linux/gather/enum_configs
msf6 post(linux/gather/enum_configs) > set SESSION [SESSION_ID]
msf6 post(linux/gather/enum_configs) > run
msf6 post(linux/gather/enum_configs) > use post/linux/gather/enum_networks
msf6 post(linux/gather/enum_networks) > set SESSION [SESSION_ID]
msf6 post(linux/gather/enum_networks) > run
msf6 post(linux/gather/enum_networks) > run
msf6 post(linux/gather/enum_networks) > use post/linux/gather/enum_system
msf6 post(linux/gather/enum_system) > set SESSION [SESSION_ID]
msf6 post(linux/gather/enum_system) > run
msf6 post(linux/gather/enum_system) > use post/linux/gather/checkvm
msf6 post(linux/gather/checkvm) > set SESSION [SESSION_ID]
msf6 post(linux/gather/checkvm) > run
meterpreter > cd /tmp
meterpreter > upload linpeas.sh
meterpreter > upload linenum.sh
$ chmod +x linpeas.sh linenum.sh
$ ./linpeas.sh > lin-peas
$ ./linenum.sh > lin-enum
```


