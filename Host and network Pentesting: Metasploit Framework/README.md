# Table of Contents

- [Metasloit Framework Overview](#1)
  - [Introduction to Metasploit](#1.1)
    - [Terminology](#1.1.1)
    - [Metasploit Framework Interfaces](#1.1.2)
      - [Metasploit Console](#1.1.2.1)
      - [MSFcli](#1.1.2.2)
      - [Metasploit Community Edition](#1.1.2.3)
      - [Armitage](#1.1.2.4)
  - [Metasploit Architecture](#1.2)
    - [Metasploit Modules](#1.2.1)
    - [Types of payloads](#1.2.2)
    - [Meterpreter Payload](#1.2.3)
    - [Metasploit Modules Locations](#1.2.4)
  - [Pentesting with Metasploit](#1.3)
    - [Penetration Testing Execution Standard](#1.3.1)
    - [Pentesting Phases](#1.3.2)
    - [How the Metasploit Framework is integrated into each phase.](#1.3.3)
- [Metasploit Fundamentals](#2)
  - [Installation and configuration](#2.1)
    - [The Metasploit Framework Database](#2.1.1)
  - [MSFConsole fundamentals](#2.2)
    - [What we need to know](#2.2.1)
    - [Metasploit Variables](#2.2.1)
  - [Creating and managing a workspace](#2.3)
- [Information Gathering and Enumeration with Metasploit](#3)
  - [Port scanning and enumeration with Nmap](#3.1)
  - [Port scanning and enumeration with auxiliary modules](#3.2)
    - [Lab Infrastructure](#3.2.1)
  - [FTP Enumeration](#3.3)
  - [SMB Enumeration](#3.4)
  - [Web Server Enumeration](#3.5)
  - [MySQL Enumeration](#3.6)
  - [SSH Login](#3.7)
  - [SMTP Enumeration](#3.8)

<a id=1></a>
# Metasloit Framework Overview

<a id=1.1></a>
## Introduction to Metasploit

The Metasploit Framework is an open-source tool developed for penetration testing.

It provides pentesters with a robust infrastructure required to automate every stage of
a pentest.

It's also used by exploit developers to develop and test their new exploits.

The Metasploit Framework is designed to be modular, allowing for new functions to be added easily
by the user.

The framework was developed initially by HD Moore in 2003. It was originally written in Perl.

It was then acquired by Rapid7 in 2009 and rewritten in Ruby.

There are three editions of Metasploit:

- Metasploit Pro (Commercial)
- Metasploit Express (Commercial)
- Metasploit Framework (Community)

<a id=1.1.1></a>
### Terminology

- Interface: Methods of interaction with the Metasploit Framework.
- Module: Pieces of coda that performa a particular task, an example of a module is an exploit.
- Vulnerability: weakness or flaw in a computer system.
- Exploit: piece of code that is used to take advantage of a vulnerability
- Payload: piece of code delivered to the target by an exploit to execute arbitrary commands.
- Listener: a utility that listens for incoming connections.

<a id=1.1.2></a>
### Metasploit Framework Interfaces

<a id=1.1.2.1></a>
#### Metasploit Console.

All-in-one interface that provides us with complete access to all functionalities of the
Metasploit Framework.

<a id=1.1.2.2></a>
#### MSFcli

The msfcli is a command line utility used to facilitate the communications between another
tools to the Metasploit Console.

It was discontinued, but the same functionality can be obtained using the console.

<a id=1.1.2.3></a>
#### Metasploit Community Edition

Is a web-based GUI front-end for the MSF console that simplifies network discovery and vulnerability
identification. 

<a id=1.1.2.4></a>
#### Armitage

It's a GUI-based Metasploit Console written in Java.

<a id=1.2></a>
## Metasploit Architecture

A module in the context of MSF, is a piece of code that can be used by the MSF

The MSF libraries facilitate the execution of modules without having to write the code
necessary in order to execute them.

- Libraries: MSFbase, MSFcore, Rex
- Modules: exploit, payload, encoder, nop, auxiliary

<a id=1.2.1></a>
### MSF Modules

- Exploit: a module used to take advantage of a vulnerability and is typically paired with
a payload.
- Payload: code that is delivered by MSF and remotely executed on the target after successful exploitation.
- Encoder: used to encode payloads in order to avoid AV detection. For example, `shikaga_ga_nai` is used to
encode Windows payloads.
- NOPS: used to ensure that payloads sizes are consistent and ensure the stability of a payload when executed.
- Auxiliary: a module that is used to perform additional functionality like port scanning and enumeration.

<a id=1.2.2></a>
### Types of payloads:

- Non-staged: payload that is sent to the target system along the exploit.
- Staged: payload that is sent to the target after the exploit has been successful.
	- stager: contains a payload used to establish a reverse connection to the attacker.
	- stage: the actual payload, responsible for executing arbitrary commands.

<a id=1.2.3></a>
### Meterpreter payload

The meterpreter payload is an advanced multi-functional framework allocated in memory of the target.
Being in memory makes it harder for antivirus to detect it.

It communicates over a stager socket and provide the attacker with an interactive command inteperter
on the exploited system. 

<a id=1.2.4></a>
### MSF Module Locations

```bash
/usr/share/metasploit-framework/modules # built-in modules
~/.ms4/modules # custom modules
```

<a id=1.3></a>
## Pentesting with Metasploit

The MSF can be used to perform and automate various tasks that fall under the pentest life cycle.

We will explore the various phases of a pentest to understand how to use the framework.

We will adopt the PTES (Pentest Execution Standard) as a roadman to understand the various
phases that make up a pentest and how Metasploit can be integrated into each phase.

<a id=1.3.1></a>
### Penetration Testing Execution Standard

The PTES is a pentesting methodology that was developed by a team of IS practicioners with the
aim of addressing the need for a comprehensive and up-to-date standard for pentesting.

[Check the wiki clicking here](http://www.pentest-standard.org/index.php/Main_Page)

<a id=1.3.2></a>
### Pentesting Phases

- Information gathering
- Enumeration
- Exploitation
- Post-exploitation
	- Privilege escalation
	- Mantaining persistent access
	- Clearing tracks

<a id=1.3.3></a>
### How the Metasploit Framework is integrated into each phase.

| PTES Phase                                    | Metasploit Implementation     |
| --------------------------------------------- | ----------------------------- |
| Information gathering and enumeration         | Auxiliary modules             |
| Vulnerability scanning                        | Auxiliary modules, Nessus     |
| Exploitation                                  | Exploit modules and paylaods  |
| Post-exploitation                             | Meterpreter                   |
| Privilege escalation                          | Post-exploitation modules     |
| Mantaning persistent access                   | Post-exploitation modules     |

<a id=2></a>
# Metasploit Fundamentals

<a id=2.1></a>
## Installion and configuration

The MSF is distributed by Rapid7 and can be downloaded and installed as a standalone package on both
Windows and Linux.

Nevertheless, we will use Linux. Kali, Parrot and Blackarch can be used. In neither distro do we have to install
anything, but we should update our packages. 

<a id=2.1.1></a>
### The Metasploit Framework Database

The msfdb is an integral part of the framework and is used to keep track of all you assessments, host data scans, etc.

The framework uses PostgreSQL as the primary database server, as a result, we will also need to ensure that the PostgreSQL
database service is running and configured correctly.

It also facilitates the importation of storaged scan results from tools like Nessus or Nmap.

```bash
$ sudo pacman -S metasploit-framework
$ sudo systemctl enable postgresql
$ sudo systemctl start postgresql
$ sudo msfdb init 
```

<a id=2.2></a>
## MSFConsole Fundamentals

Before starting to pentest, we need to get a grasp on how to utilize the MSF console.

The console is an easy-to-use AIO interface that gives us complete access to the framework.

Every phase of the pentest can be done from here.

<a id=2.2.1></a>
### What we need to know.

1. How to search for modules.
2. How to select modules.
3. How to configure module options and variables.
4. How to search for payloads.
5. Managing sessions.
6. Additional funcitonality
7. Saving our configurations

<a id=2.2.2></a>
### MSF Module Variables

Modules will typically require information like target IPs or ports to begin exploitation.

There options are configured through MSF set variables.

The console allows us to set local and global variable values.

Let's see some common types of variables.

| Variable      | Purpose                                                                               |
| ------------- | ------------------------------------------------------------------------------------- |
| LHOST         | Our address. Used to configure payloads and correctly set up listeners.               |
| LPORT         | A port for our listener to hear.                                                      |
| RHOST         | A remote host. Our target.                                                            |
| RHOSTS        | An amount of remote hosts. Some modules allow for multiple uses at the same time.     |
| RPORT         | Port to attack.                                                                       |

Let's use the console!

```bash
msf6 > help 
# print the help menu.
msf6 > version 
# display the metasploit version
msf6 > show all 
# print all the available modules 
msf6 > show exploits 
# print only exploit modules
# lets do something practical like a scan.
msf6 > search portscan
# this will list some modules.
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > options
# prints the options of the current module
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS 127.0.0.1
# sets the rhosts variable.
msf6 auxiliary(scanner/portscan/tcp) > set PORTS 1-1000
# set a range of ports to scan.
msf6 auxiliary(scanner/portscan/tcp) > run
# starts the scan
msf6 > search cve:2017 type:exploit platform:windows
# filter by searching only CVE exploits on windows
msf6> search eternalblue
# searches for an eternalblue exploit
msf6> connect [TARGET] [PORT]
# helpful to do banner grabbing
```

<a id=2.3></a>
## Creating and managing a workspace

Workspaces allow us to keep track of all the hosts, scans and activities and is extremely useful when
conducting penetration tests as they allow us to sort and organize the data.

The console provides us with the ability to create, manage and switch between multiple workspaces
depending on the requirements we have.

We will be using workspaces to organize our assignments as we progress through the course.

Lets see how to do it! 

```bash
msf6 > db_status
# checks the msfdb status
msf6 > workspace -h 
# prints workspace help
msf6 > workspace
# shows existing workspaces
msf6 > hosts
# prints the hosts stores in the workspace
msf6 > workspace -a [WORKSPACE NAME]
# creates and switches to a workspace
msf6 > workspace [EXISTING_WORKSPACE]
# switches to a workspace
msf6 > workspace -d [WORKSPACE]
# deletes a workspace
msf6 > workspace -r [OLD_WORKSPACE_NAME] [NEW_WORKSPACE_NAME]
# renames a workspace
```

<a id=3></a>
# Information Gathering and Enumeration with Metasploit

<a id=3.1></a>
## Port scanning and enumeration with Nmap

Nmap is a free and open source tool to perform network scans, port scans a more features.

It can also be used to enumerate services running on a machine.

We can output the results of Nmap to the Metasploit Console in a format that can be imported
to the console and later used in our pentesting.

```bash
$ nmap [TARGET]
# perform an everyday scan with Nmap.
$ nmap [TARGET] -oX [FILENAME]
# this will output the scan results into an XML file. this file will be used and
# imported to the msfconsole for later use.
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace [NAME]
# lets first create a workspace before loading the XML file.
msf6 > db_import /path/to/file.xml
# this will load the file and be accessible from the msfconsole database
msf6 > services
# displays the services known to the database
msf6 > db_nmap [NMAP_OPTIONS] [TARGET]
# perform an nmap scan directly from the msfconsole. this will automatically take the
# data and store it in the database
msf6 > vulns
# if we were to find a vulnerability, it will be stored there
```

<a id=3.2></a>
## Port scanning and enumeration with auxiliary modules

Auxiliary modules are used to perform scans, discovery and fuzzing.

We can use them to perform both TCP and UDP port scanning as well as enumerating information
from services like FTP, SSH, etc.

These can be used during the information gathering phase of a penetetration test.

We can also run scans after exploitation on the target network.

Auxiliary modules, while very useful during recon, are most powerful on the post-exploitation
phase of the pentest.

<a id=3.2.1></a>
### Lab Infrastructure

Our objetive in this lab will be to utilize auxiliary modules to discover open ports on our
first target.

The next step will involve exploiting the service running on the target in order to obtain
a foothold.

From then we will pivot to different servers using scanning and exploits.

```bash
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > show options
# we need to choose the RHOSTS and RPORT range.
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS [NETWORK_CIDR_TARGET] {OR} [TARGET]
msf6 auxiliary(scanner/portscan/tcp) > set RPORT 1-1000
# a more thorough port-scan would consider a range from 1 to 65535.
meterpreter > shell
ip a
# this will give us the IP address from the machine. from this we can scan the internal
# network. 
meterpreter > run autoroute -s [INTERNAL_TARGET]
meterpreter > bg
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS [INTERNAL_TARGET]
msf6 auxiliary(scanner/portscan/tcp) > run
# done! we have successfully scanned the internal target.
msf6 auxiliary(scanner/portscan/tcp) > use auxiliary/scanner/discovery/udp_sweep
msf6 auxiliary(scanner/discovery/udp_sweep) > set [TARGET]
```

<a id=3.3></a>
## FTP Enumeration

We can use auxiliary modules to enumerate information as well as perform bruteforce attacks
on targets running an FTP service.

FTP authentication utilizes a username and password, however in some cases a misconfigured FTP
server may use anonymous logins, which consists on user anonymous and a blank password.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workpace -a FTP_Enumeration
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/portscan/tcp) > set RPORT 21
msf6 auxiliary(scanner/portscan/tcp) > run
# service is UP
msf6 auxiliary(scanner/portscan/tcp) > search ftp
# a shit ton of FTP modules appear.
msf6 auxiliary(scanner/portscan/tcp) > search type:auxiliary name:ftp
# reduced search
msf6 auxiliary(scanner/portscan/tcp) > use auxiliary/scanner/ftp/ftp_version
msf6 auxiliary(scanner/ftp/ftp_version) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/ftp/ftp_version) > run
msf6 auxiliary(scanner/ftp/ftp_version) > use auxiliary/scanner/ftp/ftp_login
msf6 auxiliary(scanner/ftp/ftp_login) > set USER_FILE /path/to/usernames
msf6 auxiliary(scanner/ftp/ftp_login) > set PASS_FILE /path/to/passwords
# msfconsole has built-in user and password lists for bruteforcing, so we dont have to pass
# a list to the module.
msf6 auxiliary(scanner/ftp/ftp_login) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/ftp/ftp_login) > set THREADS [THREADS]
# you can change the number of concurrent tasks. improves speed, but its noisy!
# and maybe the FTP server won't like that.
msf6 auxiliary(scanner/ftp/ftp_login) > run
msf6 auxiliary(scanner/ftp/ftp_login) > use auxiliary/scanner/ftp/anonymous
msf6 auxiliary(scanner/ftp/anonymous) > set RHOSTS [TARGET]
msf6 auxiliary(scanner/ftp/anonymous) > run
# if an ftp shell is not opened, then the service is not misconfigured.
msf6 auxiliary(scanner/ftp/anonymous) > 
msf6 auxiliary(scanner/ftp/anonymous) > 
```

<a id=3.4></a>
## SMB Enumeration

We will use auxiliary modules to scan an SMB service, its shares and more.

We can scan both SMB and Samba services. They're both found on 445, although older
versions are on 139 and 445.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a SMB_Enumeration
msf6 > setg RHOSTS [TARGET]
# set the target as global variable.
msf6 > search type:auxiliary name:smb
msf6 > use auxiliary/scanner/smb/smb_version
msf6 auxiliary(scanner/smb/smb_version) > run
msf6 auxiliary(scanner/smb/smb_version) > use auxiliary/scanner/smb/smb_enumusers
msf6 auxiliary(scanner/smb/smb_enumusers) > run
# as a lot of SMB/Samba servers allow NULL sessions, in most cases its not necessary
# to set the user and password variables. but we can do it, though.
msf6 auxiliary(scanner/smb/smb_enumusers) > set SMBUser [USER]
msf6 auxiliary(scanner/smb/smb_enumusers) > set SMBPass [PASSWORD]
msf6 auxiliary(scanner/smb/smb_enumusers) > use auxiliary/scanner/smb/smb_enumshares
msf6 auxiliary(scanner/smb/smb_enumshares) > set ShowFiles true
# optional variable. this will spider and show us the files within the shares.
msf6 auxiliary(scanner/smb/smb_enumshares) > run
# again, its not necessary to set credentials, but lets do it anyway.
msf6 auxiliary(scanner/smb/smb_enumshares) > set SMBUser [USER]
msf6 auxiliary(scanner/smb/smb_enumshares) > set SMBPass [PASSWORD]
msf6 auxiliary(scanner/smb/smb_enumshares) > use auxiliary/scanner/smb/smb_login
msf6 auxiliary(scanner/smb/smb_login) > set SMBUser admin 
# we will only select one user.
msf6 auxiliary(scanner/smb/smb_login) > set PASS_FILE /path/to/passwords
msf6 auxiliary(scanner/smb/smb_login) > set STOP_ON_SUCCESS true
# stops the bruteforce whenever we get a hit.
msf6 auxiliary(scanner/smb/smb_login) > run
msf6 auxiliary(scanner/smb/smb_login) > exit
msf6 > exit
$ smbclient -L \\\\[TARGET]\\ -U admin
# this is outside the console, but its good to know. the previous command enumerates
# the shares on the target
$ smbclient \\\\[TARGET]\\[SHARE]-U admin
smb: \> haxxord
```

<a id=3.5></a>
## Web Server Enumeration

We will use auxiliary modules to enumerate and scan a web server. Some of them are Apache, 
IIS, Nginx and more. Most of the time they're located at port 80, 443, 8080 and 8888.

```bash
$ systemctl start postgresql && msfdb init && msfconsole
msf6 > workspace -a WS_Enum
msf6 > setg RHOSTS [TARGET]
msf6 > setg RHOST [TARGET]
msf6 > search type:auxiliary name:http
msf6 > use auxiliary/scanner/http/http_version
msf6 auxiliary(scanner/http/http_version) > run
msf6 auxiliary(scanner/http/http_version) > use auxiliary/scanner/http/http_header
msf6 auxiliary(scanner/http/http_header) > run
msf6 auxiliary(scanner/http/http_header) > use auxiliary/scanner/http/robots_txt
msf6 auxiliary(scanner/http/robots_txt) > run
msf6 auxiliary(scanner/http/robots_txt) > curl http://[TARGET]/[PATH]
# we can check the disallowed directories.
msf6 auxiliary(scanner/http/) > use auxiliary/scanner/http/dir_scanner
msf6 auxiliary(scanner/http/dir_scanner) > set DICTIONARY /path/to/http_paths
# the console uses a default dict, so we dont need to change it.
msf6 auxiliary(scanner/http/dir_scanner) > run
msf6 auxiliary(scanner/http/files_dir) > set EXT [EXTENSION]
# search for particular type of files.
msf6 auxiliary(scanner/http/files_dir) > use auxiliary/scanner/http/http_login
msf6 auxiliary(scanner/http/http_login) > set AUTH_URI /path/to/http_login
msf6 auxiliary(scanner/http/http_login) > set BRUTEFORCE_SPEED [1-5]
msf6 auxiliary(scanner/http/http_login) > unset USERPASS_FILE 
msf6 auxiliary(scanner/http/http_login) > set USER_FILE /path/to/user
msf6 auxiliary(scanner/http/http_login) > set PASS_FILE /path/to/passwords
msf6 auxiliary(scanner/http/http_login) > set STOP_ON_SUCCESS true
msf6 auxiliary(scanner/http/http_login) > set VERBOSE false
# we can make it so it doesn't show failed attempts. i don't like this because i feel
# like nothing is happening lol
msf6 auxiliary(scanner/http/http_login) > run
msf6 auxiliary(scanner/http/http_login) > use auxiliary/scanner/http/apache_userdir_enum
msf6 auxiliary(scanner/http/apache_userdir_enum) > set USER_FILE /path/to/users
msf6 auxiliary(scanner/http/apache_userdir_enum) > run
```

<a id=3.6></a>
## MySQL Enumeration

<a id=3.7></a>
## SSH Enumeration and Login

<a id=3.8></a>
## SMTP Enumeration
