# Table of Contents

- [HTTP Protocol](#1)
  - [HTTP Headers](#1.1)
  - [HTTP Methods](#1.2)
  - [HTTP Status codes](#1.3)
  - [HTTP... S?](#1.4)
- [The WEB!](#2)
  - [Web pages](#2.1)
  - [Web apps](#2.2)
- [HTTP Method Enumeration](#3)
- [Directory Enumeration](#4)
- [Nikto Scanning](#5)
- [SQL Injection with SQLMap](#6)
- [XSS attacks with XSSer](#7)
- [Attacking HTTP Login Forms with Hydra](#8)


<a id=1></a>
# HTTP Protocol

The HTTP (HyperText Transfer Protocol) protocol is, in practical terms, what most people know as "the Internet". It's used to
host websites, web applications, device administration tools, and more. They way it works can be described as a conversation.

The client asks for something and the server sends it back. For this communication, HTTP needs a dialect, a common language. And
that common language is most known as the HTTP methods.

<a id=1.1></a>
## HTTP Headers

An HTTP header is a piece of data that contains information like the browser you're using, the web server engine, what methods you're
currently trying to use, status codes, and more.

<a id=1.2></a>
## HTTP Methods

The methods are the verbs the client -- typically -- uses to fetch or send information to a web server. Some of them are:

- GET: asks the server for something.
- HEAD: only sends and receives the HTTP headers.
- POST: sends information to the server.
- PUT: upload a file to a web server that allows file sharing. 
- UPDATE: updates an existing resource on the web server.

The latter are not all the methods that exist for HTTP. For a more comprehensive read, you can check the [RFC 9110.](https://www.rfc-editor.org/rfc/rfc9110#name-method-definitions)
And even then, the ones in the RFC are not **all** the available HTTP methods, as the protocol itself is extensible and can be
modified and more methods can be added.

<a id=1.3></a>
## HTTP Status Codes

Not always will you get what you want from a web server. Sometimes you can ask for a webpage that doesn't exist and you get a 404.
That's as status code. But more exist:

- 1xx: informational status code.
- 2xx: successful status code.
- 3xx: redirections status code.
- 4xx: client error.
- 5xx: server error.

<a id=1.4></a>
## HTTP... S?

HTTPS is an extension of HTTP that provides encrypted communications between a client and a server. It's not its own protocol as
most people think, but rather a way to send and receive HTTP information.

<a id=2></a>
# The WEB!

<a id=2.1></a>
## Web pages

A website is a static, HTML-based web resource. It's usually written in HTML and sometimes combined with PHP or Javascript.
Typically accessible through web-servers, although local versions can be ran without a server. 

<a id=2.2></a>
## Webapps

Webapps are ~~a bloated version of websites~~ software programs accessible through a browser. Examples like goPhish, MSFPro,
all come in mind. 

<a id=3></a>
# HTTP Method Enumeration

When doing a web pentest, the first thing that we want to do is reconnaissance. And the first step of that recon, is
getting to know which methods does the web site or app allow. Now, there are a few ways of doing this.

Let's see how to do it manually.

```bash
$ curl -X GET/HEAD/POST/PUT... [URL/URI]
# you can do this recursively with every method. 
```

Or you could use the script I wrote and it's on this same repo. It's quite simple and written in Bash. I won't explain it,
as it's commented very well and it's simple to read. Nmap also has a script called `http-methods`.

<a id=4></a>
# Directory Enumeration

Directory enumeration is the process of searching for existing directories accessible within a webserver. Many applications
can be used to do this task, and some can be misused to also do this task. Let's see some of them.

```bash
$ dirb http://example.com /path/to/wordlist
$ gobuster dir -u http://example.com -w /path/to/wordlist
$ ffuf -w /path/to/wordlist -u http://example.com/FUZZ
# the FUZZ keyword is a must set. that is because the program will look for that word and replace it with the
# ones contained in the wordlist. ffuf is a very versatile tool, and if speed is needed and/or allowed, i always
# go for ffuf instead or gobuster or dirb.
```

You can also use tools like Burpsuite to do directory enumeration, but I think that's kind of overkill. Also goes against
the UNIX principles, but you do you girl.

<a id=5></a>
# Nikto Scanning

Nikto is a free and open source web vulnerability scanner. It's terminal based, so therefore only kool kidz use it.

Let's see how it works.

```bash
$ nikto -h http://example.com
$ nikto -h http://example.com -Display V
# for verbosity
$ nikto -h http://example.com -Tuning [0-9abcx]
# tune the nikto scan. check the manpage
$ nikto -h http://example.com -o nikto_output -Format [csv,txt,xml,htlm]
# create an output report.
```

This is just the basic power of Nikto. Get yourself familiarized with it, read the manpage and learn more about it!

<a id=6></a>
# SQL Injection with SQLMap

SQLmap is a tool that automates SQL injection attacks. It's very good for beginners, as it gives the opportunity to
understand what the tool thinks and in some cases why it picks certain payloads. Nevertheless, this tool is bested
by the fact that it will not find complex attacks like error-based timing attacks. 

Let's try it.

```bash
$ sqlmap -u "http://example.com/endpoint.php" 
# run it without any parameters. useless.
$ sqlmap -u "http://example.com/endpoint.php" --cookie "[COOKIE]" -p [TARGET]
# pass a cookie and a target parameter
$ sqlmap -u "http://example.com/endpoint.php" --cookie "[COOKIE]" -p [TARGET] --dbs
# sqlmap will try to get the tables on the dbms
$ sqlmap -u "http://example.com/endpoint.php" --cookie "[COOKIE]" -p [TARGET] -D [DATABASE] --tables
# returns the tables from DATABASE
$ sqlmap -u "http://example.com/endpoint.php" --cookie "[COOKIE]" -p [TARGET] -D [DATABASE] -T [TABLE] --columns
# returns the columns on the TABLE found in the DATABASE
$ sqlmap -u "http://example.com/endpoint.php" --cookie "[COOKIE]" -p [TARGET] -D [DATABASE] -T [TABLE] -C [COLUMNS]
# returns the values found in COLUMN
$ sqlmap -r [REQUEST] -p [TARGET]
# use an existing request and use it to attack TARGET
```

<a id=7></a>
# XSS attacks with XSSer

XSSer is a tool that helps automate XSS attacks. Similar to SQlmap, this tool is bested by more complex attacks,
but it's still useful in some cases.

Let's try it.

```bash
$ xsser --url "http://example.com/endpoint.php" -p "[TARGET]=XSS"
# attack TARGET and put XSS wherever you want the payloads to go. similar to ffuf
$ xsser --url "http://example.com/endpoint.php" -p "[TARGET]=XSS" --fp "<script>alert(window.origin)</script>"
# use your own payload
$ xsser --url "http://example.com/endpoint.php" -p "[TARGET]=XSS" --fp "<script>alert(window.origin)</script>" --cookie "[COOKIE]"
# authenticated attack. you'll need a cookie for this.
```

<a id=8></a>
# Attacking HTTP Login Forms with Hydra

As we know, Hydra is a tool to crack passwords and hashes. It's used to attack a multitude of services, and one of
them is HTTP Basic authentication forms. Although not a service, it's capable of attacking them.

Let's see how.

```bash
$ hydra -L /path/to/usernames -P /path/to/passwords [TARGET] http-post-form "/loginform.php:username=^USERNAME^&password=^PASSWORD^:BadLoginRegex"
# this is the basic functionality. the loginform.php may be different, and the username= and password= might also be
# different. it'll depend on the target, so check the source code of the webpage or check the requests with Burpsuite.
```
